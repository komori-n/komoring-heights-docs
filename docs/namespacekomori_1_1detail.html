<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KomoringHeights: komori::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KomoringHeights
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekomori.html">komori</a></li><li class="navelem"><a class="el" href="namespacekomori_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">komori::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Detail.  
<a href="namespacekomori_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_default_ordered_map.html">DefaultOrderedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">look up 時にキーが存在しない時はデフォルト値を返す ordered_map。  <a href="classkomori_1_1detail_1_1_default_ordered_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1detail_1_1_dfpn_plus_parameters.html">DfpnPlusParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">df-pn+ で用いるパラメータたち  <a href="structkomori_1_1detail_1_1_dfpn_plus_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_mate_len_impl.html">MateLenImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>MateLen</code> と <code>MateLen16</code> の実装本体。中身はほぼ同じなので一箇所にまとめる。  <a href="classkomori_1_1detail_1_1_mate_len_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1detail_1_1_has_begin_and_end_members.html">HasBeginAndEndMembers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> が begin と end メンバ関数を持っているかどうか判定するメタ関数  <a href="structkomori_1_1detail_1_1_has_begin_and_end_members.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_with_index_impl.html">WithIndexImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>WithIndex</code> の実装本体  <a href="classkomori_1_1detail_1_1_with_index_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_skip_impl.html">SkipImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Skep</code> の実装本体  <a href="classkomori_1_1detail_1_1_skip_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_take_impl.html">TakeImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Take</code> の実装本体  <a href="classkomori_1_1detail_1_1_take_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1detail_1_1_zip_impl.html">ZipImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Zip</code> の実装本体  <a href="classkomori_1_1detail_1_1_zip_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1detail_1_1_constraints_impl.html">ConstraintsImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Args...</code> を無視して<code>Type</code> に <code>std::nullptr_t</code> を定義するメタ関数  <a href="structkomori_1_1detail_1_1_constraints_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1detail_1_1_anything.html">Anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の値でコンストラクトできる空構造体。 <code>ConsumeValue()</code> で用いる。  <a href="structkomori_1_1detail_1_1_anything.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a1ee47b3617f7a51661ec137724e0fb"><td class="memTemplParams" colspan="2">template&lt;typename OutType  = s64&gt; </td></tr>
<tr class="memitem:a7a1ee47b3617f7a51661ec137724e0fb"><td class="memTemplItemLeft" align="right" valign="top">OutType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a7a1ee47b3617f7a51661ec137724e0fb">ReadOption</a> (const USI::OptionsMap &amp;o, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7a1ee47b3617f7a51661ec137724e0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">オプション <code>o</code> から <code>name</code> の値を読み込む  <a href="namespacekomori_1_1detail.html#a7a1ee47b3617f7a51661ec137724e0fb">More...</a><br /></td></tr>
<tr class="separator:a7a1ee47b3617f7a51661ec137724e0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2c92e509802b03a01e4d018c22d8ea"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a7b2c92e509802b03a01e4d018c22d8ea">MakeInfIfNotPositive</a> (std::int64_t val)</td></tr>
<tr class="memdesc:a7b2c92e509802b03a01e4d018c22d8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>val</code> が0以下なら 2^64-1 を返す。  <a href="namespacekomori_1_1detail.html#a7b2c92e509802b03a01e4d018c22d8ea">More...</a><br /></td></tr>
<tr class="separator:a7b2c92e509802b03a01e4d018c22d8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8c39e028338e1c24e97418bf751772"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a7e8c39e028338e1c24e97418bf751772">InitialPnDnPlusOrNode</a> (const Position &amp;n, Move move)</td></tr>
<tr class="memdesc:a7e8c39e028338e1c24e97418bf751772"><td class="mdescLeft">&#160;</td><td class="mdescRight">df-pn+における OR node の pn/dn 初期値を計算する  <a href="namespacekomori_1_1detail.html#a7e8c39e028338e1c24e97418bf751772">More...</a><br /></td></tr>
<tr class="separator:a7e8c39e028338e1c24e97418bf751772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e953984699bd0e99000f56bc96dcb9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a56e953984699bd0e99000f56bc96dcb9">InitialPnDnPlusAndNode</a> (const Position &amp;n, Move move)</td></tr>
<tr class="memdesc:a56e953984699bd0e99000f56bc96dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">df-pn+における AND node の pn/dn 初期値を計算する  <a href="namespacekomori_1_1detail.html#a56e953984699bd0e99000f56bc96dcb9">More...</a><br /></td></tr>
<tr class="separator:a56e953984699bd0e99000f56bc96dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730c115105733a5cbffe37428c86ce5a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classkomori_1_1_search_result.html">SearchResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a730c115105733a5cbffe37428c86ce5a">CheckObviousFinalOrNode</a> (<a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n)</td></tr>
<tr class="memdesc:a730c115105733a5cbffe37428c86ce5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR node <code>n</code> を <code>move</code> した局面が自明な詰み／不詰かどうかを判定する。  <a href="namespacekomori_1_1detail.html#a730c115105733a5cbffe37428c86ce5a">More...</a><br /></td></tr>
<tr class="separator:a730c115105733a5cbffe37428c86ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723abd115e7a47a8c4072b9b1e7f7dd2"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a723abd115e7a47a8c4072b9b1e7f7dd2"><td class="memTemplItemLeft" align="right" valign="top">std::false_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a723abd115e7a47a8c4072b9b1e7f7dd2">HasBeginAndEndMembersCheck</a> (long)</td></tr>
<tr class="memdesc:a723abd115e7a47a8c4072b9b1e7f7dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> が begin と end メンバ関数を持っているかどうか判定するダミー関数（never defined）  <a href="namespacekomori_1_1detail.html#a723abd115e7a47a8c4072b9b1e7f7dd2">More...</a><br /></td></tr>
<tr class="separator:a723abd115e7a47a8c4072b9b1e7f7dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffad50024d3e4e836976c4bdb7dec01"><td class="memTemplParams" colspan="2">template&lt;typename Range , Constraints&lt; decltype(std::declval&lt; Range &gt;().begin()), decltype(std::declval&lt; Range &gt;().end())&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:abffad50024d3e4e836976c4bdb7dec01"><td class="memTemplItemLeft" align="right" valign="top">std::true_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#abffad50024d3e4e836976c4bdb7dec01">HasBeginAndEndMembersCheck</a> (int)</td></tr>
<tr class="memdesc:abffad50024d3e4e836976c4bdb7dec01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> が begin と end メンバ関数を持っているかどうか判定するダミー関数（never defined）  <a href="namespacekomori_1_1detail.html#abffad50024d3e4e836976c4bdb7dec01">More...</a><br /></td></tr>
<tr class="separator:abffad50024d3e4e836976c4bdb7dec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf0cecc656d96fca9addfb4c90816f"><td class="memTemplParams" colspan="2">template&lt;typename Range , Constraints&lt; std::enable_if_t&lt; std::is_array_v&lt; std::remove_reference_t&lt; Range &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a65bf0cecc656d96fca9addfb4c90816f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a65bf0cecc656d96fca9addfb4c90816f">call_begin</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range) noexcept(noexcept(std::begin(std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range))))</td></tr>
<tr class="memdesc:a65bf0cecc656d96fca9addfb4c90816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">range-based for の要件に従って begin をコールする関数（配列版）  <a href="namespacekomori_1_1detail.html#a65bf0cecc656d96fca9addfb4c90816f">More...</a><br /></td></tr>
<tr class="separator:a65bf0cecc656d96fca9addfb4c90816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144bd1e9041f7686eede4096fcdfad22"><td class="memTemplParams" colspan="2">template&lt;typename Range , Constraints&lt; std::enable_if_t&lt; std::is_array_v&lt; std::remove_reference_t&lt; Range &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a144bd1e9041f7686eede4096fcdfad22"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a144bd1e9041f7686eede4096fcdfad22">call_end</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range) noexcept(noexcept(std::end(std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range))))</td></tr>
<tr class="memdesc:a144bd1e9041f7686eede4096fcdfad22"><td class="mdescLeft">&#160;</td><td class="mdescRight">range-based for の要件に従って end をコールする関数（配列版）  <a href="namespacekomori_1_1detail.html#a144bd1e9041f7686eede4096fcdfad22">More...</a><br /></td></tr>
<tr class="separator:a144bd1e9041f7686eede4096fcdfad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe71454b986eab9bbd9936ebfb3d4c22"><td class="memItemLeft" align="right" valign="top"><a id="abe71454b986eab9bbd9936ebfb3d4c22"></a>
constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#abe71454b986eab9bbd9936ebfb3d4c22">HashfullCheckInterval</a> (std::uint64_t capacity) noexcept</td></tr>
<tr class="memdesc:abe71454b986eab9bbd9936ebfb3d4c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">HashfullCheck の周期を計算する <br /></td></tr>
<tr class="separator:abe71454b986eab9bbd9936ebfb3d4c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af96273f392e89ff2fae85a958348299e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkomori_1_1detail_1_1_default_ordered_map.html">DefaultOrderedMap</a>&lt; std::string, <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11">ScoreCalculationMethod</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#af96273f392e89ff2fae85a958348299e">score_caluclation_option</a></td></tr>
<tr class="memdesc:af96273f392e89ff2fae85a958348299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">評価値計算方法 <code>ScoreCalculationMethod</code> 用の Combo 定義。  <a href="namespacekomori_1_1detail.html#af96273f392e89ff2fae85a958348299e">More...</a><br /></td></tr>
<tr class="separator:af96273f392e89ff2fae85a958348299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e94751612a22494bb717838fca9283"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkomori_1_1detail_1_1_default_ordered_map.html">DefaultOrderedMap</a>&lt; std::string, <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0">PostSearchLevel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#ae2e94751612a22494bb717838fca9283">post_search_level</a></td></tr>
<tr class="memdesc:ae2e94751612a22494bb717838fca9283"><td class="mdescLeft">&#160;</td><td class="mdescRight">余詰探索方法 <code>PostSearchLevel</code> 用の Combo 定義。  <a href="namespacekomori_1_1detail.html#ae2e94751612a22494bb717838fca9283">More...</a><br /></td></tr>
<tr class="separator:ae2e94751612a22494bb717838fca9283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e555fab5fcccd104d35021efb273a24"><td class="memItemLeft" align="right" valign="top">thread_local int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a0e555fab5fcccd104d35021efb273a24">tl_pt_values</a> []</td></tr>
<tr class="memdesc:a0e555fab5fcccd104d35021efb273a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">駒のざっくりとした価値。スレッドごとに微妙に乱数を加えたいので thread_local にしている。  <a href="namespacekomori_1_1detail.html#a0e555fab5fcccd104d35021efb273a24">More...</a><br /></td></tr>
<tr class="separator:a0e555fab5fcccd104d35021efb273a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64ca8b15fdf9c7b808402de0f5b685c"><td class="memItemLeft" align="right" valign="top"><a id="af64ca8b15fdf9c7b808402de0f5b685c"></a>
thread_local <a class="el" href="structkomori_1_1detail_1_1_dfpn_plus_parameters.html">DfpnPlusParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#af64ca8b15fdf9c7b808402de0f5b685c">tl_dfpn_plus_parameters</a></td></tr>
<tr class="memdesc:af64ca8b15fdf9c7b808402de0f5b685c"><td class="mdescLeft">&#160;</td><td class="mdescRight">df-pn+ で用いるパラメータ。スレッドごとに微妙に乱数を加えたいので thread_local にしている。 <br /></td></tr>
<tr class="separator:af64ca8b15fdf9c7b808402de0f5b685c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337cef6e1a5e1743969cf71ff1597b3d"><td class="memItemLeft" align="right" valign="top"><a id="a337cef6e1a5e1743969cf71ff1597b3d"></a>
constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a337cef6e1a5e1743969cf71ff1597b3d">kForceSumPnDn</a> = <a class="el" href="namespacekomori.html#a26c6a28d0272596fcb24312758455681">kInfinitePnDn</a> / 1024</td></tr>
<tr class="memdesc:a337cef6e1a5e1743969cf71ff1597b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">強制的に max 値によるδ値計算へ切り替えるしきい値。 <br /></td></tr>
<tr class="separator:a337cef6e1a5e1743969cf71ff1597b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae757db16d451c5423f3e6556067a15ad"><td class="memItemLeft" align="right" valign="top"><a id="ae757db16d451c5423f3e6556067a15ad"></a>
HASH_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#ae757db16d451c5423f3e6556067a15ad">g_move_from</a> [SQ_NB_PLUS1][<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">komori::kDepthMax</a>]</td></tr>
<tr class="memdesc:ae757db16d451c5423f3e6556067a15ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">移動元に関する経路ハッシュ値 <br /></td></tr>
<tr class="separator:ae757db16d451c5423f3e6556067a15ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c685703f632bcda700d230797608b"><td class="memItemLeft" align="right" valign="top"><a id="a3f3c685703f632bcda700d230797608b"></a>
HASH_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a3f3c685703f632bcda700d230797608b">g_move_to</a> [SQ_NB_PLUS1][<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">komori::kDepthMax</a>]</td></tr>
<tr class="memdesc:a3f3c685703f632bcda700d230797608b"><td class="mdescLeft">&#160;</td><td class="mdescRight">移動先に関する経路ハッシュ値 <br /></td></tr>
<tr class="separator:a3f3c685703f632bcda700d230797608b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c56f2de853fd55d913b9bd53e64b1"><td class="memItemLeft" align="right" valign="top"><a id="a831c56f2de853fd55d913b9bd53e64b1"></a>
HASH_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a831c56f2de853fd55d913b9bd53e64b1">g_promote</a> [<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">komori::kDepthMax</a>]</td></tr>
<tr class="memdesc:a831c56f2de853fd55d913b9bd53e64b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">成りを区別するための経路ハッシュ値 <br /></td></tr>
<tr class="separator:a831c56f2de853fd55d913b9bd53e64b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e746cc55ea6913b4a56fbce665ebe4"><td class="memItemLeft" align="right" valign="top"><a id="a69e746cc55ea6913b4a56fbce665ebe4"></a>
HASH_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a69e746cc55ea6913b4a56fbce665ebe4">g_dropped_pr</a> [PIECE_HAND_NB][<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">komori::kDepthMax</a>]</td></tr>
<tr class="memdesc:a69e746cc55ea6913b4a56fbce665ebe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">駒打ちに関する経路ハッシュ値 <br /></td></tr>
<tr class="separator:a69e746cc55ea6913b4a56fbce665ebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27891fba964c6f33e366432899a627"><td class="memItemLeft" align="right" valign="top"><a id="a2e27891fba964c6f33e366432899a627"></a>
HASH_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a2e27891fba964c6f33e366432899a627">g_stolen_pr</a> [PIECE_HAND_NB][<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">komori::kDepthMax</a>]</td></tr>
<tr class="memdesc:a2e27891fba964c6f33e366432899a627"><td class="mdescLeft">&#160;</td><td class="mdescRight">駒強奪（無駄合防止探索用）に関する経路ハッシュ値 <br /></td></tr>
<tr class="separator:a2e27891fba964c6f33e366432899a627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d474e46fd918c222fc95277f663d5a"><td class="memItemLeft" align="right" valign="top"><a id="a44d474e46fd918c222fc95277f663d5a"></a>
constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html#a44d474e46fd918c222fc95277f663d5a">kHashfullCheeckSkipRatio</a> = 4096</td></tr>
<tr class="memdesc:a44d474e46fd918c222fc95277f663d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">HashfullCheck をスキップする回数の割合 <br /></td></tr>
<tr class="separator:a44d474e46fd918c222fc95277f663d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Detail. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a65bf0cecc656d96fca9addfb4c90816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bf0cecc656d96fca9addfb4c90816f">&#9670;&nbsp;</a></span>call_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , Constraints&lt; std::enable_if_t&lt; std::is_array_v&lt; std::remove_reference_t&lt; Range &gt;&gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::detail::call_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range-based for の要件に従って begin をコールする関数（配列版） </p>
<p>range-based for の要件に従って begin をコールする関数（フリー関数版）</p>
<p>range-based for の要件に従って begin をコールする関数（メンバ関数版）</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>配列</td></tr>
    <tr><td class="paramname">range</td><td>begin と end をメンバ関数に持つクラス</td></tr>
    <tr><td class="paramname">range</td><td>配列でなく、かつ begin と end をメンバ関数に持たないクラス </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00042">42</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="a144bd1e9041f7686eede4096fcdfad22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144bd1e9041f7686eede4096fcdfad22">&#9670;&nbsp;</a></span>call_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , Constraints&lt; std::enable_if_t&lt; std::is_array_v&lt; std::remove_reference_t&lt; Range &gt;&gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::detail::call_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range-based for の要件に従って end をコールする関数（配列版） </p>
<p>range-based for の要件に従って end をコールする関数（フリー関数版）</p>
<p>range-based for の要件に従って end をコールする関数（メンバ関数版）</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>配列</td></tr>
    <tr><td class="paramname">range</td><td>begin と end をメンバ関数に持つクラス</td></tr>
    <tr><td class="paramname">range</td><td>配列でなく、かつ begin と end をメンバ関数に持たないクラス </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00073">73</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="a730c115105733a5cbffe37428c86ce5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c115105733a5cbffe37428c86ce5a">&#9670;&nbsp;</a></span>CheckObviousFinalOrNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classkomori_1_1_search_result.html">SearchResult</a>&gt; komori::detail::CheckObviousFinalOrNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OR node <code>n</code> を <code>move</code> した局面が自明な詰み／不詰かどうかを判定する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
    <tr><td class="paramname">move</td><td>次の手 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> を <code>move</code> で進めた局面が自明な詰みまたは不詰ならその結果を返す。それ以外なら <code>std::nullopt</code> を返す。</dd></dl>
<p>末端局面における固定深さ探索。詰め探索で必須ではないが、これによって高速化することができる。</p>
<p>高速 1 手詰めルーチンおよび高速 0 手不詰ルーチンにより自明な詰み／不詰を展開することなく検知することができる。 </p>

<p class="definition">Definition at line <a class="el" href="local__expansion_8hpp_source.html#l00038">38</a> of file <a class="el" href="local__expansion_8hpp_source.html">local_expansion.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_1_1detail_a730c115105733a5cbffe37428c86ce5a_cgraph.png" border="0" usemap="#anamespacekomori_1_1detail_a730c115105733a5cbffe37428c86ce5a_cgraph" alt=""/></div>
<map name="anamespacekomori_1_1detail_a730c115105733a5cbffe37428c86ce5a_cgraph" id="anamespacekomori_1_1detail_a730c115105733a5cbffe37428c86ce5a_cgraph">
<area shape="rect" title="OR node n を move した局面が自明な詰み／不詰かどうかを判定する。" alt="" coords="5,612,219,653"/>
<area shape="rect" href="namespacekomori.html#af60b97ffafc4e100347e046e86ef02ac" title="(OR node限定) n が 1 手詰かどうか判定する。" alt="" coords="300,493,476,519"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="1082,442,1222,469"/>
<area shape="rect" href="namespacekomori.html#afa08995342dc8f460d6de738cd457571" title="(OR node限定) n が不詰かどうかを簡易的に調べる。" alt="" coords="267,670,509,697"/>
<area shape="rect" href="namespacekomori.html#ace83f8e2ffff818bd25b6def2e075904" title="move 後の手駒が after_hand のとき、移動前の持ち駒を返す" alt="" coords="575,493,727,519"/>
<area shape="rect" href="classkomori_1_1_node.html#a082d5d0045420c8978206fda2b518e17" title="move で1手進める" alt="" coords="565,274,736,301"/>
<area shape="rect" href="classkomori_1_1_node.html#aad7fe2734b150a1d9645ea72e2fdda83" title="DoMove() で進めた局面を元に戻す" alt="" coords="557,429,744,455"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a5f9f4c0e10424bb96f652c18cfc6afc7" title="スタックの末尾（最も後に保存した要素）" alt="" coords="812,351,984,392"/>
<area shape="rect" href="classkomori_1_1_node.html#afc3ff609d7a14aae03aab36317148f63" title="現在の盤面ハッシュ値" alt="" coords="809,299,987,326"/>
<area shape="rect" href="classkomori_1_1_node.html#a2c10b9d22f4966f51b47495088f4fd4b" title="現在の攻め方の持ち駒" alt="" coords="815,417,981,443"/>
<area shape="rect" href="classkomori_1_1_node.html#a6dfeb2e63ce33d5b9043010cbb8428c3" title="move 後の経路ハッシュ値" alt="" coords="1052,34,1252,61"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a122fd54c4b21ad3d1ce129cf1b2d6f3f" title="val をスタックに追加する" alt="" coords="812,52,984,93"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a3ba89e53fbe90e03b07b2c68eea98334" title="(board_key, hand) を履歴に登録する" alt="" coords="823,117,973,159"/>
<area shape="rect" href="namespacekomori.html#ae0ab7ef1101897b620e05208fc8975ee" title="現在の path_key と手 move から1手後の path_key を計算する。" alt="" coords="1300,343,1459,370"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a62769876f5547de5b474300c666cea8a" title="index の次のインデックスを求める" alt="" coords="1077,117,1227,159"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#ab3ed82ca4c526f4f34c90c9277ba7d5b" title="board_key に対する探索開始インデックスを求める" alt="" coords="1077,183,1227,224"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a3af0755f672c9b15c72253aebc682aa5" title="(board_key, hand) を履歴から消す" alt="" coords="823,183,973,224"/>
<area shape="rect" href="classkomori_1_1_node.html#a7f1c13d7f57b6af7f34ac77240342d71" title="move 直前の経路ハッシュ値" alt="" coords="792,670,1004,697"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a30a23ee0ab5980d4fad72185cafed9d0" title="スタックから要素を1つ削除する" alt="" coords="796,518,1000,545"/>
<area shape="rect" href="namespacekomori.html#af65c288516ec71f448f2947aac9e755b" title="1手後の path_key と手 move から現在の path_key を計算する。" alt="" coords="1067,569,1237,595"/>
</map>
</div>

</div>
</div>
<a id="abffad50024d3e4e836976c4bdb7dec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffad50024d3e4e836976c4bdb7dec01">&#9670;&nbsp;</a></span>HasBeginAndEndMembersCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , Constraints&lt; decltype(std::declval&lt; Range &gt;().begin()), decltype(std::declval&lt; Range &gt;().end())&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::true_type komori::detail::HasBeginAndEndMembersCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> が begin と end メンバ関数を持っているかどうか判定するダミー関数（never defined） </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a></td><td>範囲 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723abd115e7a47a8c4072b9b1e7f7dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723abd115e7a47a8c4072b9b1e7f7dd2">&#9670;&nbsp;</a></span>HasBeginAndEndMembersCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::false_type komori::detail::HasBeginAndEndMembersCheck </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> が begin と end メンバ関数を持っているかどうか判定するダミー関数（never defined） </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a></td><td>範囲 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56e953984699bd0e99000f56bc96dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e953984699bd0e99000f56bc96dcb9">&#9670;&nbsp;</a></span>InitialPnDnPlusAndNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&gt; komori::detail::InitialPnDnPlusAndNode </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>df-pn+における AND node の pn/dn 初期値を計算する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
    <tr><td class="paramname">move</td><td>次の手 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> を <code>move</code> で動かした局面の pn/dn の初期値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00127">127</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>

</div>
</div>
<a id="a7e8c39e028338e1c24e97418bf751772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8c39e028338e1c24e97418bf751772">&#9670;&nbsp;</a></span>InitialPnDnPlusOrNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&gt; komori::detail::InitialPnDnPlusOrNode </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>df-pn+における OR node の pn/dn 初期値を計算する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
    <tr><td class="paramname">move</td><td>次の手 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> を <code>move</code> で動かした局面の pn/dn の初期値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00087">87</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>

</div>
</div>
<a id="a7b2c92e509802b03a01e4d018c22d8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2c92e509802b03a01e4d018c22d8ea">&#9670;&nbsp;</a></span>MakeInfIfNotPositive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t komori::detail::MakeInfIfNotPositive </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>val</code> が0以下なら 2^64-1 を返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>val</code> が正ならその値、それ以外なら 2^64-1 を返す。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00134">134</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<a id="a7a1ee47b3617f7a51661ec137724e0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1ee47b3617f7a51661ec137724e0fb">&#9670;&nbsp;</a></span>ReadOption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutType  = s64&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutType komori::detail::ReadOption </td>
          <td>(</td>
          <td class="paramtype">const USI::OptionsMap &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>オプション <code>o</code> から <code>name</code> の値を読み込む </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutType</td><td>出力値の型。<code>s64</code> や <code>std::string</code> など。デフォルト値は <code>s64</code>。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>エンジンオプション </td></tr>
    <tr><td class="paramname">name</td><td>読み込みキー </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>name</code> に対応する値</dd></dl>
<p>もし <code>o[name]</code> が存在しないなら <code>OutType{}</code> を返す。 </p>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00121">121</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae2e94751612a22494bb717838fca9283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e94751612a22494bb717838fca9283">&#9670;&nbsp;</a></span>post_search_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkomori_1_1detail_1_1_default_ordered_map.html">DefaultOrderedMap</a>&lt;std::string, <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0">PostSearchLevel</a>&gt; komori::detail::post_search_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;MinLength&quot;</span>,</div>
<div class="line">    PostSearchLevel::kNone,</div>
<div class="line">    {</div>
<div class="line">        {<span class="stringliteral">&quot;None&quot;</span>, PostSearchLevel::kNone},</div>
<div class="line">        {<span class="stringliteral">&quot;UpperBound&quot;</span>, PostSearchLevel::kUpperBound},</div>
<div class="line">        {<span class="stringliteral">&quot;MinLength&quot;</span>, PostSearchLevel::kMinLength},</div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>余詰探索方法 <code>PostSearchLevel</code> 用の Combo 定義。 </p>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00101">101</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<a id="af96273f392e89ff2fae85a958348299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96273f392e89ff2fae85a958348299e">&#9670;&nbsp;</a></span>score_caluclation_option</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkomori_1_1detail_1_1_default_ordered_map.html">DefaultOrderedMap</a>&lt;std::string, <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11">ScoreCalculationMethod</a>&gt; komori::detail::score_caluclation_option</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;Ponanza&quot;</span>,</div>
<div class="line">    ScoreCalculationMethod::kPonanza,</div>
<div class="line">    {</div>
<div class="line">        {<span class="stringliteral">&quot;None&quot;</span>, ScoreCalculationMethod::kNone},</div>
<div class="line">        {<span class="stringliteral">&quot;Dn&quot;</span>, ScoreCalculationMethod::kDn},</div>
<div class="line">        {<span class="stringliteral">&quot;MinusPn&quot;</span>, ScoreCalculationMethod::kMinusPn},</div>
<div class="line">        {<span class="stringliteral">&quot;Ponanza&quot;</span>, ScoreCalculationMethod::kPonanza},</div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>評価値計算方法 <code>ScoreCalculationMethod</code> 用の Combo 定義。 </p>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00089">89</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<a id="a0e555fab5fcccd104d35021efb273a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e555fab5fcccd104d35021efb273a24">&#9670;&nbsp;</a></span>tl_pt_values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local int komori::detail::tl_pt_values[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0, 10, 20, 20, 30, 50, 50, 50, 80, 50, 50, 50, 50, 80, 80, 80,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>駒のざっくりとした価値。スレッドごとに微妙に乱数を加えたいので thread_local にしている。 </p>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00016">16</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
