<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KomoringHeights: komori Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KomoringHeights
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">komori Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Komoring Heights.  
<a href="namespacekomori.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacekomori_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacekomori_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detail. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacekomori_1_1tt"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori_1_1tt.html">tt</a></td></tr>
<tr class="memdesc:namespacekomori_1_1tt"><td class="mdescLeft">&#160;</td><td class="mdescRight">TranspositionTable. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_bit_set.html">BitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">整数 <code>T</code> を用いたフラグ集合。  <a href="classkomori_1_1_bit_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_board_key_hand_pair.html">BoardKeyHandPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">盤面ハッシュ値と攻め方の持ち駒のペア。これがあれば TT から結果を取得できる。  <a href="structkomori_1_1_board_key_hand_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_circular_array.html">CircularArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">長さ <code>kSize</code> 、型 <code>T</code> の循環配列。  <a href="classkomori_1_1_circular_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_delayed_move_list.html">DelayedMoveList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">指し手の遅延展開を判断するクラス。  <a href="classkomori_1_1_delayed_move_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_branch_root_edge.html">BranchRootEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">二重カウントの可能性がある辺。 FindKnownAncestor の戻り値に用いる。  <a href="structkomori_1_1_branch_root_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_engine_option.html">EngineOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">エンジンオプションの事前読み込みおよび提供を行うクラス。  <a href="structkomori_1_1_engine_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_expansion_stack.html">ExpansionStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classkomori_1_1_local_expansion.html" title="局面の局所展開結果を保持する。">LocalExpansion</a></code> をスタックで管理するクラス。  <a href="classkomori_1_1_expansion_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_fixed_size_stack.html">FixedSizeStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">サイズ固定のスタック。  <a href="classkomori_1_1_fixed_size_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_proof_hand_tag.html">ProofHandTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkomori_1_1_hand_set.html" title="子局面の証明駒 or 反証駒をもとに、現局面の証明駒 or 反証駒を求めるクラス。">HandSet</a> の初期化時に使うタグ（AND nodeの証明駒）  <a href="structkomori_1_1_proof_hand_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_disproof_hand_tag.html">DisproofHandTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkomori_1_1_hand_set.html" title="子局面の証明駒 or 反証駒をもとに、現局面の証明駒 or 反証駒を求めるクラス。">HandSet</a> の初期化時に使うタグ（OR nodeの反証駒）  <a href="structkomori_1_1_disproof_hand_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_hand_set.html">HandSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">子局面の証明駒 or 反証駒をもとに、現局面の証明駒 or 反証駒を求めるクラス。  <a href="classkomori_1_1_hand_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_komoring_heights.html">KomoringHeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰将棋探索の本体  <a href="classkomori_1_1_komoring_heights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_local_expansion.html">LocalExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面の局所展開結果を保持する。  <a href="classkomori_1_1_local_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_move_picker.html">MovePicker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰将棋探索用の指し手生成器  <a href="classkomori_1_1_move_picker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Position</code> をラップして詰将棋特有の判定を追加するクラス。  <a href="classkomori_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_periodic_alarm.html">PeriodicAlarm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">一定間隔で通知するアラーム  <a href="classkomori_1_1_periodic_alarm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_pv_list.html">PvList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">各手の探索結果とPVのリスト。  <a href="classkomori_1_1_pv_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">イテレータの範囲を表す型。  <a href="classkomori_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_score.html">Score</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在の探索状況に基づく評価値。  <a href="classkomori_1_1_score.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_search_monitor.html">SearchMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">探索局面数を観測して nps を計算したり探索中断の判断をしたりするクラス。  <a href="classkomori_1_1_search_monitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_unknown_data.html">UnknownData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">結論が出ていないノード（Unknown）の探索結果  <a href="structkomori_1_1_unknown_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_final_data.html">FinalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">結論が出てたノード（Final）の探索結果  <a href="structkomori_1_1_final_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_search_result.html">SearchResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">探索結果をやり取りするためのクラス。  <a href="classkomori_1_1_search_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_search_result_comparer.html">SearchResultComparer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classkomori_1_1_search_result.html" title="探索結果をやり取りするためのクラス。">SearchResult</a></code> 同士の半順序関係。  <a href="classkomori_1_1_search_result_comparer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_shared_exclusive_lock.html">SharedExclusiveLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::atomic を用いた Shared-Exclusive lock  <a href="classkomori_1_1_shared_exclusive_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_spin_lock.html">SpinLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::atomic_flag</code> を用いたスピンロック  <a href="classkomori_1_1_spin_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_identity.html">Identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>T</code> をそのまま返すメタ関数。  <a href="structkomori_1_1_identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_define_not_equal_by_equal.html">DefineNotEqualByEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>operator==</code> から <code>operator!=</code> を自動定義するクラス。  <a href="structkomori_1_1_define_not_equal_by_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomori_1_1_define_comparison_operators_by_less.html">DefineComparisonOperatorsByLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>operator&lt;</code> から各種演算子を自動定義するクラス。  <a href="structkomori_1_1_define_comparison_operators_by_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_usi_info.html">UsiInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USIプロトコルに従い探索情報（info）を整形するクラス  <a href="classkomori_1_1_usi_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomori_1_1_visit_history.html">VisitHistory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">探索履歴を管理し、千日手や優等局面の判定を行うクラス。  <a href="classkomori_1_1_visit_history.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a20dc4ee64c842a7caa36c7cf7496ce61"><td class="memItemLeft" align="right" valign="top"><a id="a20dc4ee64c842a7caa36c7cf7496ce61"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a20dc4ee64c842a7caa36c7cf7496ce61">BitSet64</a> = <a class="el" href="classkomori_1_1_bit_set.html">BitSet</a>&lt; std::uint64_t &gt;</td></tr>
<tr class="memdesc:a20dc4ee64c842a7caa36c7cf7496ce61"><td class="mdescLeft">&#160;</td><td class="mdescRight">64ビット整数を用いたフラグ集合。よく使う（というかこれしか使わない）のでここで型定義しておく。 <br /></td></tr>
<tr class="separator:a20dc4ee64c842a7caa36c7cf7496ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c3856a7c53116227693f8dcca64199"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a> = <a class="el" href="classkomori_1_1detail_1_1_mate_len_impl.html">detail::MateLenImpl</a>&lt; std::uint32_t &gt;</td></tr>
<tr class="memdesc:af2c3856a7c53116227693f8dcca64199"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰み／不詰手数  <a href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">More...</a><br /></td></tr>
<tr class="separator:af2c3856a7c53116227693f8dcca64199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b173701f7efb9de640cd66a993a0af2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a> = <a class="el" href="classkomori_1_1detail_1_1_mate_len_impl.html">detail::MateLenImpl</a>&lt; std::uint16_t &gt;</td></tr>
<tr class="memdesc:a5b173701f7efb9de640cd66a993a0af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰み／不詰手数（<code>MateLen</code> の16ビット版）  <a href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">More...</a><br /></td></tr>
<tr class="separator:a5b173701f7efb9de640cd66a993a0af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fb0edd05205e09790d1b3f440dc196"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a55fb0edd05205e09790d1b3f440dc196"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a55fb0edd05205e09790d1b3f440dc196">Constraints</a> = typename <a class="el" href="structkomori_1_1detail_1_1_constraints_impl.html">detail::ConstraintsImpl</a>&lt; Args... &gt;::Type</td></tr>
<tr class="memdesc:a55fb0edd05205e09790d1b3f440dc196"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE の制約を書くのに便利な型。  <a href="namespacekomori.html#a55fb0edd05205e09790d1b3f440dc196">More...</a><br /></td></tr>
<tr class="separator:a55fb0edd05205e09790d1b3f440dc196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b179f7c8adb463807f13c9d73ec34a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> = std::uint64_t</td></tr>
<tr class="memdesc:ae2b179f7c8adb463807f13c9d73ec34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">証明数／反証数を格納する型  <a href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">More...</a><br /></td></tr>
<tr class="separator:ae2b179f7c8adb463807f13c9d73ec34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077cff4c0bde489c0330a39b102a21bf"><td class="memItemLeft" align="right" valign="top"><a id="a077cff4c0bde489c0330a39b102a21bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a077cff4c0bde489c0330a39b102a21bf">SearchAmount</a> = std::uint32_t</td></tr>
<tr class="memdesc:a077cff4c0bde489c0330a39b102a21bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">探索量。TTでエントリを消す際の判断に用いる。 <br /></td></tr>
<tr class="separator:a077cff4c0bde489c0330a39b102a21bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adc4d7ccfd98577a6c7e7d9830b9add11"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11">ScoreCalculationMethod</a> { <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11a3a603030c47fb8af0037af651f00e110">kDn</a>
, <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11a90342bf1b782eb2a96b24391f4f61693">kMinusPn</a>
, <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11a236068ef7962d525e144dcb55732165d">kPonanza</a>
 }</td></tr>
<tr class="memdesc:adc4d7ccfd98577a6c7e7d9830b9add11"><td class="mdescLeft">&#160;</td><td class="mdescRight">評価値の計算方法。詰将棋エンジンでは評価値を計算する決まった方法がないので選べるようにしておく。  <a href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11">More...</a><br /></td></tr>
<tr class="separator:adc4d7ccfd98577a6c7e7d9830b9add11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8bac3d10dabcca8f1933216eb2d7f0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0">PostSearchLevel</a> { <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0a653007906d4d1c6cd05c5517dff4786e">kUpperBound</a>
, <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0afde98040dc0c46ca54b30798d8190c54">kMinLength</a>
 }</td></tr>
<tr class="memdesc:a0f8bac3d10dabcca8f1933216eb2d7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">余詰探索の度合い。  <a href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0">More...</a><br /></td></tr>
<tr class="separator:a0f8bac3d10dabcca8f1933216eb2d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a4eeb6080f15a12a946bf93ff7488"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488">NodeState</a> { <a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488a25c2dc47991b3df171ed5192bcf70390">kUnknown</a>
, <a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488a91941e19d11188fa06c946a61bef1d7d">kProven</a>
, <a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488ac07a394d06065193a8cbf2f53000b916">kDisproven</a>
, <a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488a0da05df76ef6b213939d96600064949d">kRepetition</a>
 }</td></tr>
<tr class="memdesc:ada1a4eeb6080f15a12a946bf93ff7488"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面の探索状態。  <a href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488">More...</a><br /></td></tr>
<tr class="separator:ada1a4eeb6080f15a12a946bf93ff7488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5d6d57beee6813c2cf957fab95cd53"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53">UsiInfoKey</a> { <br />
&#160;&#160;<a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53af588847884f09f744af48ef8d9a0eda8">kSelDepth</a>
, <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a4fbae144eab5d83a51adcf4d6542805a">kTime</a>
, <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a160413698c72c216b33f26d67f394d26">kNodes</a>
, <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a98d4711a6e938752ae25d67a5de61391">kNps</a>
, <br />
&#160;&#160;<a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a709f077202ab7f8fac38e174044968b9">kHashfull</a>
, <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a01b0b332aabe7b2d016322deab8b3aea">kCurrMove</a>
, <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53a42cd9f8462e879f12a7bdddfb5743080">kScore</a>
<br />
 }</td></tr>
<tr class="memdesc:a7f5d6d57beee6813c2cf957fab95cd53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UsiInfo::Set()</code> で設定可能なUSIオプション一覧  <a href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53">More...</a><br /></td></tr>
<tr class="separator:a7f5d6d57beee6813c2cf957fab95cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8a333a0a9dfda36b2fc53731711e1f3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structkomori_1_1_branch_root_edge.html">BranchRootEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#aa8a333a0a9dfda36b2fc53731711e1f3">FindKnownAncestor</a> (<a class="el" href="namespacekomori_1_1tt.html#ab367c034eba59afd3939578f638b0ffb">tt::TranspositionTable</a> &amp;tt, const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, Move move)</td></tr>
<tr class="memdesc:aa8a333a0a9dfda36b2fc53731711e1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>n</code> を <code>move</code> した局面から置換表をたどると <code>n</code> の祖先に行き着くかどうか調べる  <a href="namespacekomori.html#aa8a333a0a9dfda36b2fc53731711e1f3">More...</a><br /></td></tr>
<tr class="separator:aa8a333a0a9dfda36b2fc53731711e1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f3fa8cf78887150c3558bf0ebbf47c"><td class="memItemLeft" align="right" valign="top"><a id="a48f3fa8cf78887150c3558bf0ebbf47c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a48f3fa8cf78887150c3558bf0ebbf47c">RemoveHand</a> (Hand &amp;hand, PieceType pr)</td></tr>
<tr class="memdesc:a48f3fa8cf78887150c3558bf0ebbf47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">hand から pr を消す <br /></td></tr>
<tr class="separator:a48f3fa8cf78887150c3558bf0ebbf47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910cf44bbf31dae9af184770f7ca5dd4"><td class="memItemLeft" align="right" valign="top"><a id="a910cf44bbf31dae9af184770f7ca5dd4"></a>
Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a910cf44bbf31dae9af184770f7ca5dd4">MergeHand</a> (Hand h1, Hand h2)</td></tr>
<tr class="memdesc:a910cf44bbf31dae9af184770f7ca5dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 つの持ち駒を 1 つにまとめる <br /></td></tr>
<tr class="separator:a910cf44bbf31dae9af184770f7ca5dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a8276a5be421edb3f7cbaa1bbb92d1"><td class="memItemLeft" align="right" valign="top"><a id="ae9a8276a5be421edb3f7cbaa1bbb92d1"></a>
Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae9a8276a5be421edb3f7cbaa1bbb92d1">CollectHand</a> (const Position &amp;n)</td></tr>
<tr class="memdesc:ae9a8276a5be421edb3f7cbaa1bbb92d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">先後の持ち駒（盤上にない駒）を全てかき集める <br /></td></tr>
<tr class="separator:ae9a8276a5be421edb3f7cbaa1bbb92d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7384744353766bfb79e581a03fb381d"><td class="memItemLeft" align="right" valign="top"><a id="ab7384744353766bfb79e581a03fb381d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ab7384744353766bfb79e581a03fb381d">CountHand</a> (Hand hand)</td></tr>
<tr class="memdesc:ab7384744353766bfb79e581a03fb381d"><td class="mdescLeft">&#160;</td><td class="mdescRight">持ち駒の枚数 <br /></td></tr>
<tr class="separator:ab7384744353766bfb79e581a03fb381d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5838f0a6fe258eb2bc0197498cd7358"><td class="memItemLeft" align="right" valign="top"><a id="ae5838f0a6fe258eb2bc0197498cd7358"></a>
Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae5838f0a6fe258eb2bc0197498cd7358">AfterHand</a> (const Position &amp;n, Move move, Hand before_hand)</td></tr>
<tr class="memdesc:ae5838f0a6fe258eb2bc0197498cd7358"><td class="mdescLeft">&#160;</td><td class="mdescRight">move 後の手駒を返す <br /></td></tr>
<tr class="separator:ae5838f0a6fe258eb2bc0197498cd7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace83f8e2ffff818bd25b6def2e075904"><td class="memItemLeft" align="right" valign="top"><a id="ace83f8e2ffff818bd25b6def2e075904"></a>
Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ace83f8e2ffff818bd25b6def2e075904">BeforeHand</a> (const Position &amp;n, Move move, Hand after_hand)</td></tr>
<tr class="memdesc:ace83f8e2ffff818bd25b6def2e075904"><td class="mdescLeft">&#160;</td><td class="mdescRight">move 後の手駒が after_hand のとき、移動前の持ち駒を返す <br /></td></tr>
<tr class="separator:ace83f8e2ffff818bd25b6def2e075904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b91824ee210b1157a170f0b0dc650cb"><td class="memItemLeft" align="right" valign="top">Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a2b91824ee210b1157a170f0b0dc650cb">ApplyDeltaHand</a> (Hand target, Hand diff_src, Hand diff_dst)</td></tr>
<tr class="memdesc:a2b91824ee210b1157a170f0b0dc650cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">持ち駒 <code>target</code> に <code>diff_dst - diff_src</code> を加える  <a href="namespacekomori.html#a2b91824ee210b1157a170f0b0dc650cb">More...</a><br /></td></tr>
<tr class="separator:a2b91824ee210b1157a170f0b0dc650cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf7170c2ef58b6054c0ac2c51dab4ba"><td class="memItemLeft" align="right" valign="top">Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a2bf7170c2ef58b6054c0ac2c51dab4ba">RemoveIfHandGivesOtherChecks</a> (const Position &amp;n, Hand disproof_hand)</td></tr>
<tr class="memdesc:a2bf7170c2ef58b6054c0ac2c51dab4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面 n の子局面がすべて 反証駒 disproof_hand で不詰であることが既知の場合、もとの局面 n の反証駒を計算する。  <a href="namespacekomori.html#a2bf7170c2ef58b6054c0ac2c51dab4ba">More...</a><br /></td></tr>
<tr class="separator:a2bf7170c2ef58b6054c0ac2c51dab4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78bf2e5661e6a5459917ea76c2d560"><td class="memItemLeft" align="right" valign="top">Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#abe78bf2e5661e6a5459917ea76c2d560">AddIfHandGivesOtherEvasions</a> (const Position &amp;n, Hand proof_hand)</td></tr>
<tr class="memdesc:abe78bf2e5661e6a5459917ea76c2d560"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面 n の子局面がすべて証明駒 proof_hand で詰みであることが既知の場合、もとの局面 n の証明駒を計算する。  <a href="namespacekomori.html#abe78bf2e5661e6a5459917ea76c2d560">More...</a><br /></td></tr>
<tr class="separator:abe78bf2e5661e6a5459917ea76c2d560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0674ce184ef6aec644ffb45a0b021bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a0674ce184ef6aec644ffb45a0b021bb5">InitBriefEvaluation</a> (std::uint32_t thread_id)</td></tr>
<tr class="memdesc:a0674ce184ef6aec644ffb45a0b021bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">初期評価値を乱数でずらす  <a href="namespacekomori.html#a0674ce184ef6aec644ffb45a0b021bb5">More...</a><br /></td></tr>
<tr class="separator:a0674ce184ef6aec644ffb45a0b021bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6a82becf6ccac969ecceaf30f5b95a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a5c6a82becf6ccac969ecceaf30f5b95a">InitialPnDn</a> (const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, Move move)</td></tr>
<tr class="memdesc:a5c6a82becf6ccac969ecceaf30f5b95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">初めて訪れた局面の pn/dn 初期値を計算する  <a href="namespacekomori.html#a5c6a82becf6ccac969ecceaf30f5b95a">More...</a><br /></td></tr>
<tr class="separator:a5c6a82becf6ccac969ecceaf30f5b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ffdadd3d71c7adb2f85aa0bead587"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a1b7ffdadd3d71c7adb2f85aa0bead587">MoveBriefEvaluation</a> (const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, Move move)</td></tr>
<tr class="memdesc:a1b7ffdadd3d71c7adb2f85aa0bead587"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面 n の手 move に対するざっくりとした評価値を返す。  <a href="namespacekomori.html#a1b7ffdadd3d71c7adb2f85aa0bead587">More...</a><br /></td></tr>
<tr class="separator:a1b7ffdadd3d71c7adb2f85aa0bead587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09690cec75eb5532478fb7cb04aafcb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a09690cec75eb5532478fb7cb04aafcb8">IsSumDeltaNode</a> (const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, Move move)</td></tr>
<tr class="memdesc:a09690cec75eb5532478fb7cb04aafcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">move はδ値をsumで計算すべきか／maxで計上すべきかを判定する  <a href="namespacekomori.html#a09690cec75eb5532478fb7cb04aafcb8">More...</a><br /></td></tr>
<tr class="separator:a09690cec75eb5532478fb7cb04aafcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4a7bc8f5922f5024476b6d276e0169"><td class="memItemLeft" align="right" valign="top"><a id="adb4a7bc8f5922f5024476b6d276e0169"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#adb4a7bc8f5922f5024476b6d276e0169">RollForward</a> (<a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, const std::vector&lt; Move &gt; &amp;moves)</td></tr>
<tr class="memdesc:adb4a7bc8f5922f5024476b6d276e0169"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面 n から moves で手を一気に進める。nに対し、moves の前から順に n.DoMove(m) を適用する。 <br /></td></tr>
<tr class="separator:adb4a7bc8f5922f5024476b6d276e0169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b1a743c345f921833c153fd537a50d"><td class="memItemLeft" align="right" valign="top"><a id="a13b1a743c345f921833c153fd537a50d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a13b1a743c345f921833c153fd537a50d">RollBack</a> (<a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n, const std::vector&lt; Move &gt; &amp;moves)</td></tr>
<tr class="memdesc:a13b1a743c345f921833c153fd537a50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">局面 n から moves で手を一気に戻す。n に対し、moves の後ろから順に n.UndoMove(m) を適用する。 <br /></td></tr>
<tr class="separator:a13b1a743c345f921833c153fd537a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60b97ffafc4e100347e046e86ef02ac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Move, Hand &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#af60b97ffafc4e100347e046e86ef02ac">CheckMate1Ply</a> (<a class="el" href="classkomori_1_1_node.html">Node</a> &amp;n)</td></tr>
<tr class="memdesc:af60b97ffafc4e100347e046e86ef02ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">(OR node限定) <code>n</code> が 1 手詰かどうか判定する。  <a href="namespacekomori.html#af60b97ffafc4e100347e046e86ef02ac">More...</a><br /></td></tr>
<tr class="separator:af60b97ffafc4e100347e046e86ef02ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3758efae8cd7b2132e88bdb7a145e072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a3758efae8cd7b2132e88bdb7a145e072">PathKeyInit</a> ()</td></tr>
<tr class="memdesc:a3758efae8cd7b2132e88bdb7a145e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">経路ハッシュのテーブルを初期化する。  <a href="namespacekomori.html#a3758efae8cd7b2132e88bdb7a145e072">More...</a><br /></td></tr>
<tr class="separator:a3758efae8cd7b2132e88bdb7a145e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab7ef1101897b620e05208fc8975ee"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae0ab7ef1101897b620e05208fc8975ee">PathKeyAfter</a> (Key path_key, Move move, Depth depth)</td></tr>
<tr class="memdesc:ae0ab7ef1101897b620e05208fc8975ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在の <code>path_key</code> と手 <code>move</code> から1手後の <code>path_key</code> を計算する。  <a href="namespacekomori.html#ae0ab7ef1101897b620e05208fc8975ee">More...</a><br /></td></tr>
<tr class="separator:ae0ab7ef1101897b620e05208fc8975ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65c288516ec71f448f2947aac9e755b"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#af65c288516ec71f448f2947aac9e755b">PathKeyBefore</a> (Key path_key, Move move, Depth depth)</td></tr>
<tr class="memdesc:af65c288516ec71f448f2947aac9e755b"><td class="mdescLeft">&#160;</td><td class="mdescRight">1手後の <code>path_key</code> と手 <code>move</code> から現在の <code>path_key</code> を計算する。  <a href="namespacekomori.html#af65c288516ec71f448f2947aac9e755b">More...</a><br /></td></tr>
<tr class="separator:af65c288516ec71f448f2947aac9e755b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6683308beb3ccfd868d347e93c8ac"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a2cf6683308beb3ccfd868d347e93c8ac">PathKeyAfterSteal</a> (Key path_key, PieceType stolen_pr, Depth depth)</td></tr>
<tr class="memdesc:a2cf6683308beb3ccfd868d347e93c8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">相手の持ち駒 <code>stolen_pr</code> を1枚奪った後の <code>path_key</code> を計算する。  <a href="namespacekomori.html#a2cf6683308beb3ccfd868d347e93c8ac">More...</a><br /></td></tr>
<tr class="separator:a2cf6683308beb3ccfd868d347e93c8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2d9c64c7921e22678f953901421109"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a0f2d9c64c7921e22678f953901421109">PathKeyAfterGive</a> (Key path_key, PieceType given_pr, Depth depth)</td></tr>
<tr class="memdesc:a0f2d9c64c7921e22678f953901421109"><td class="mdescLeft">&#160;</td><td class="mdescRight">相手に持ち駒 <code>stolen_pr</code> を1枚プレゼントした後の <code>path_key</code> を計算する。  <a href="namespacekomori.html#a0f2d9c64c7921e22678f953901421109">More...</a><br /></td></tr>
<tr class="separator:a0f2d9c64c7921e22678f953901421109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592455f5972570f64271d49fa7ffe9ff"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = std::size_t, typename Range  = std::nullptr_t&gt; </td></tr>
<tr class="memitem:a592455f5972570f64271d49fa7ffe9ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classkomori_1_1detail_1_1_with_index_impl.html">detail::WithIndexImpl</a>&lt; IndexType, <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a592455f5972570f64271d49fa7ffe9ff">WithIndex</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range) noexcept(noexcept(<a class="el" href="classkomori_1_1detail_1_1_with_index_impl.html">detail::WithIndexImpl</a>&lt; IndexType, <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;{std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range)}))</td></tr>
<tr class="memdesc:a592455f5972570f64271d49fa7ffe9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">添字つきのrange-based for 文用オブジェクトを生成する。  <a href="namespacekomori.html#a592455f5972570f64271d49fa7ffe9ff">More...</a><br /></td></tr>
<tr class="separator:a592455f5972570f64271d49fa7ffe9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1493fa709128d5d926e1809323c633"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a8e1493fa709128d5d926e1809323c633"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a8e1493fa709128d5d926e1809323c633">AsRange</a> (const std::pair&lt; Iterator, Iterator &gt; &amp;p) noexcept</td></tr>
<tr class="memdesc:a8e1493fa709128d5d926e1809323c633"><td class="mdescLeft">&#160;</td><td class="mdescRight">イテレータのペアで range-based for をするためのアダプタ  <a href="namespacekomori.html#a8e1493fa709128d5d926e1809323c633">More...</a><br /></td></tr>
<tr class="separator:a8e1493fa709128d5d926e1809323c633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a1de257f1363b6f913c501fa5c43c1"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ae2a1de257f1363b6f913c501fa5c43c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae2a1de257f1363b6f913c501fa5c43c1">Skip</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range, std::size_t skip) noexcept(noexcept(<a class="el" href="classkomori_1_1detail_1_1_skip_impl.html">detail::SkipImpl</a>&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;{ std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range), skip}))</td></tr>
<tr class="memdesc:ae2a1de257f1363b6f913c501fa5c43c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable の先頭 <code>kSkip</code> 要素をスキップする  <a href="namespacekomori.html#ae2a1de257f1363b6f913c501fa5c43c1">More...</a><br /></td></tr>
<tr class="separator:ae2a1de257f1363b6f913c501fa5c43c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8be37a9f85d1912131fe1379f30e70"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:acd8be37a9f85d1912131fe1379f30e70"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#acd8be37a9f85d1912131fe1379f30e70">Take</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range, std::size_t take) noexcept(noexcept(<a class="el" href="classkomori_1_1detail_1_1_take_impl.html">detail::TakeImpl</a>&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;{ std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range), take}))</td></tr>
<tr class="memdesc:acd8be37a9f85d1912131fe1379f30e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable の先頭 <code>kTake</code> 要素だけを取ってくる  <a href="namespacekomori.html#acd8be37a9f85d1912131fe1379f30e70">More...</a><br /></td></tr>
<tr class="separator:acd8be37a9f85d1912131fe1379f30e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abf9ca26f7022f402cd774514ce16a5"><td class="memTemplParams" colspan="2">template&lt;typename Range1 , typename Range2 &gt; </td></tr>
<tr class="memitem:a3abf9ca26f7022f402cd774514ce16a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a3abf9ca26f7022f402cd774514ce16a5">Zip</a> (Range1 &amp;&amp;range1, Range2 &amp;&amp;range2) noexcept(noexcept(<a class="el" href="classkomori_1_1detail_1_1_zip_impl.html">detail::ZipImpl</a>&lt; Range1, Range2 &gt;(std::forward&lt; Range1 &gt;(range1), std::forward&lt; Range2 &gt;(range2))))</td></tr>
<tr class="memdesc:a3abf9ca26f7022f402cd774514ce16a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つのrangeをpairでまとめたようなrangeを返す。  <a href="namespacekomori.html#a3abf9ca26f7022f402cd774514ce16a5">More...</a><br /></td></tr>
<tr class="separator:a3abf9ca26f7022f402cd774514ce16a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f36bba9f6289806c06f00e2c8581cc"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Func &gt; </td></tr>
<tr class="memitem:a02f36bba9f6289806c06f00e2c8581cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a02f36bba9f6289806c06f00e2c8581cc">Apply</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range, Func &amp;&amp;func) noexcept(noexcept(<a class="el" href="classkomori_1_1detail_1_1_apply_impl.html">detail::ApplyImpl</a>&lt; <a class="el" href="classkomori_1_1_range.html">Range</a>, Func &gt;{ std::forward&lt; <a class="el" href="classkomori_1_1_range.html">Range</a> &gt;(range), std::forward&lt; Func &gt;(func)}))</td></tr>
<tr class="memdesc:a02f36bba9f6289806c06f00e2c8581cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">範囲 <code>range</code> に対して関数 <code>func</code> をそれぞれ適用したような範囲を返す。  <a href="namespacekomori.html#a02f36bba9f6289806c06f00e2c8581cc">More...</a><br /></td></tr>
<tr class="separator:a02f36bba9f6289806c06f00e2c8581cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb92abe1c44b30904f85796fd729b87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#afb92abe1c44b30904f85796fd729b87e">InitializeThread</a> (std::uint32_t id, std::uint32_t num_threads)</td></tr>
<tr class="memdesc:afb92abe1c44b30904f85796fd729b87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread local 変数を初期化する  <a href="namespacekomori.html#afb92abe1c44b30904f85796fd729b87e">More...</a><br /></td></tr>
<tr class="separator:afb92abe1c44b30904f85796fd729b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad9df4bbd3b788096fc2b47251524a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a27ad9df4bbd3b788096fc2b47251524a">ConsumeValues</a> (std::initializer_list&lt; <a class="el" href="structkomori_1_1detail_1_1_anything.html">detail::Anything</a> &gt;) noexcept</td></tr>
<tr class="memdesc:a27ad9df4bbd3b788096fc2b47251524a"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の値を虚無に送る関数  <a href="namespacekomori.html#a27ad9df4bbd3b788096fc2b47251524a">More...</a><br /></td></tr>
<tr class="separator:a27ad9df4bbd3b788096fc2b47251524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7311d41d5455115265700ac2518036a7"><td class="memTemplParams" colspan="2">template&lt;typename T , Constraints&lt; std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a7311d41d5455115265700ac2518036a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a7311d41d5455115265700ac2518036a7">SaturatedAdd</a> (T lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a7311d41d5455115265700ac2518036a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>T</code> 型の値を足し合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値で丸める（符号なし型）  <a href="namespacekomori.html#a7311d41d5455115265700ac2518036a7">More...</a><br /></td></tr>
<tr class="separator:a7311d41d5455115265700ac2518036a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65253422e6bdf5544f59a4937671cf1"><td class="memTemplParams" colspan="2">template&lt;typename T , Constraints&lt; std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa65253422e6bdf5544f59a4937671cf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#aa65253422e6bdf5544f59a4937671cf1">SaturatedMultiply</a> (T lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:aa65253422e6bdf5544f59a4937671cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>T</code> 型の値を掛け合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値で丸める（符号なし型）  <a href="namespacekomori.html#aa65253422e6bdf5544f59a4937671cf1">More...</a><br /></td></tr>
<tr class="separator:aa65253422e6bdf5544f59a4937671cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c33b9356030cab989f275b6fd6ea4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a177c33b9356030cab989f275b6fd6ea4">ClampPnDn</a> (<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> val, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> min=0, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> max=<a class="el" href="namespacekomori.html#a26c6a28d0272596fcb24312758455681">kInfinitePnDn</a>)</td></tr>
<tr class="memdesc:a177c33b9356030cab989f275b6fd6ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">pn/dn の値を [<code>min</code>, <code>max</code>] の範囲に収まるように丸める。  <a href="namespacekomori.html#a177c33b9356030cab989f275b6fd6ea4">More...</a><br /></td></tr>
<tr class="separator:a177c33b9356030cab989f275b6fd6ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8d6f27caaa6caaa22610dcc422328"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a44b8d6f27caaa6caaa22610dcc422328">Phi</a> (<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> pn, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> dn, bool or_node) noexcept</td></tr>
<tr class="memdesc:a44b8d6f27caaa6caaa22610dcc422328"><td class="mdescLeft">&#160;</td><td class="mdescRight">φ値を計算する。現局面が <code>or_node</code> なら <code>pn</code>, そうでないなら <code>dn</code> を返す。  <a href="namespacekomori.html#a44b8d6f27caaa6caaa22610dcc422328">More...</a><br /></td></tr>
<tr class="separator:a44b8d6f27caaa6caaa22610dcc422328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b03d373bf7f539b7a9d8d0df9a61669"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a9b03d373bf7f539b7a9d8d0df9a61669">Delta</a> (<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> pn, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> dn, bool or_node) noexcept</td></tr>
<tr class="memdesc:a9b03d373bf7f539b7a9d8d0df9a61669"><td class="mdescLeft">&#160;</td><td class="mdescRight">δ値を計算する。現局面が <code>or_node</code> なら <code>dn</code>, そうでないなら <code>pn</code> を返す。  <a href="namespacekomori.html#a9b03d373bf7f539b7a9d8d0df9a61669">More...</a><br /></td></tr>
<tr class="separator:a9b03d373bf7f539b7a9d8d0df9a61669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e4cfe49668438b31f8af11d1043bbe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ac8e4cfe49668438b31f8af11d1043bbe">ToString</a> (<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> val)</td></tr>
<tr class="memdesc:ac8e4cfe49668438b31f8af11d1043bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">pn/dn 値を文字列に変換する  <a href="namespacekomori.html#ac8e4cfe49668438b31f8af11d1043bbe">More...</a><br /></td></tr>
<tr class="separator:ac8e4cfe49668438b31f8af11d1043bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3701bb050d01264c34af417070ac05b7"><td class="memTemplParams" colspan="2">template&lt;typename Range , Constraints&lt; decltype(std::declval&lt; Range &gt;().begin()), decltype(std::declval&lt; Range &gt;().end())&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a3701bb050d01264c34af417070ac05b7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a3701bb050d01264c34af417070ac05b7">ToString</a> (<a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;range)</td></tr>
<tr class="memdesc:a3701bb050d01264c34af417070ac05b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Move</code> の <a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> オブジェクトをスペース区切りの <code>std::string</code> へ変換する  <a href="namespacekomori.html#a3701bb050d01264c34af417070ac05b7">More...</a><br /></td></tr>
<tr class="separator:a3701bb050d01264c34af417070ac05b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8398dda0325cc3ecd032c30a01425"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ab4c8398dda0325cc3ecd032c30a01425"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ab4c8398dda0325cc3ecd032c30a01425">OrdinalNumber</a> (Integer i)</td></tr>
<tr class="memdesc:ab4c8398dda0325cc3ecd032c30a01425"><td class="mdescLeft">&#160;</td><td class="mdescRight">整数 <code>i</code> に対し、序数（Ordinal Number）の文字列を返す  <a href="namespacekomori.html#ab4c8398dda0325cc3ecd032c30a01425">More...</a><br /></td></tr>
<tr class="separator:ab4c8398dda0325cc3ecd032c30a01425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa08995342dc8f460d6de738cd457571"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#afa08995342dc8f460d6de738cd457571">DoesHaveMatePossibility</a> (const Position &amp;n)</td></tr>
<tr class="memdesc:afa08995342dc8f460d6de738cd457571"><td class="mdescLeft">&#160;</td><td class="mdescRight">(OR node限定) <code>n</code> が不詰かどうかを簡易的に調べる。  <a href="namespacekomori.html#afa08995342dc8f460d6de738cd457571">More...</a><br /></td></tr>
<tr class="separator:afa08995342dc8f460d6de738cd457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac300cf6ad5859846af0891d87ef8ec8f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ac300cf6ad5859846af0891d87ef8ec8f">kAncestorSearchThreshold</a> = 3 * <a class="el" href="namespacekomori.html#ae827eafdb768dc1d7ee921cf9a345694">kPnDnUnit</a></td></tr>
<tr class="memdesc:ac300cf6ad5859846af0891d87ef8ec8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">二重カウント回避のために局面を過去方向へ遡るとき、目をつぶる pn/dn の差  <a href="namespacekomori.html#ac300cf6ad5859846af0891d87ef8ec8f">More...</a><br /></td></tr>
<tr class="separator:ac300cf6ad5859846af0891d87ef8ec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6277ec63507731b721341c17c86699ea"><td class="memItemLeft" align="right" valign="top"><a id="a6277ec63507731b721341c17c86699ea"></a>
constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a6277ec63507731b721341c17c86699ea">kZeroMateLen</a> = <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>{0}</td></tr>
<tr class="memdesc:a6277ec63507731b721341c17c86699ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">0手詰め／0手不詰（MateLenの最小値） <br /></td></tr>
<tr class="separator:a6277ec63507731b721341c17c86699ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f2c8a8bb15674cec7f462c2a5796b0"><td class="memItemLeft" align="right" valign="top"><a id="a77f2c8a8bb15674cec7f462c2a5796b0"></a>
constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a77f2c8a8bb15674cec7f462c2a5796b0">kDepthMaxMateLen</a> = <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>{<a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">kDepthMax</a>}</td></tr>
<tr class="memdesc:a77f2c8a8bb15674cec7f462c2a5796b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">最大手数の詰み／最大手数の不詰（MateLenの最大値） <br /></td></tr>
<tr class="separator:a77f2c8a8bb15674cec7f462c2a5796b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197ec11c83aea5b797450b5c08e31279"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a197ec11c83aea5b797450b5c08e31279">kMinus1MateLen</a> = <a class="el" href="namespacekomori.html#a6277ec63507731b721341c17c86699ea">kZeroMateLen</a> - 1</td></tr>
<tr class="memdesc:a197ec11c83aea5b797450b5c08e31279"><td class="mdescLeft">&#160;</td><td class="mdescRight">-1手詰め／-1手不詰（範囲外値）  <a href="namespacekomori.html#a197ec11c83aea5b797450b5c08e31279">More...</a><br /></td></tr>
<tr class="separator:a197ec11c83aea5b797450b5c08e31279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8622a1e13915d6e31f36e1541066ce"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#aae8622a1e13915d6e31f36e1541066ce">kDepthMaxPlus1MateLen</a> = <a class="el" href="namespacekomori.html#a77f2c8a8bb15674cec7f462c2a5796b0">kDepthMaxMateLen</a> + 1</td></tr>
<tr class="memdesc:aae8622a1e13915d6e31f36e1541066ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰み／不詰手数の最大値 + 1（範囲外値）  <a href="namespacekomori.html#aae8622a1e13915d6e31f36e1541066ce">More...</a><br /></td></tr>
<tr class="separator:aae8622a1e13915d6e31f36e1541066ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d9cf0fe69668cc886621d7ad1e5c6d"><td class="memItemLeft" align="right" valign="top"><a id="ab3d9cf0fe69668cc886621d7ad1e5c6d"></a>
constexpr <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ab3d9cf0fe69668cc886621d7ad1e5c6d">kZeroMateLen16</a> = <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>{<a class="el" href="namespacekomori.html#a6277ec63507731b721341c17c86699ea">kZeroMateLen</a>}</td></tr>
<tr class="memdesc:ab3d9cf0fe69668cc886621d7ad1e5c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>kZeroMateLen</code> の 16 ビット版 <br /></td></tr>
<tr class="separator:ab3d9cf0fe69668cc886621d7ad1e5c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af95161efed3b4fa5394ec8038aeb5d"><td class="memItemLeft" align="right" valign="top"><a id="a6af95161efed3b4fa5394ec8038aeb5d"></a>
constexpr <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a6af95161efed3b4fa5394ec8038aeb5d">kDepthMaxMateLen16</a> = <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>{<a class="el" href="namespacekomori.html#a77f2c8a8bb15674cec7f462c2a5796b0">kDepthMaxMateLen</a>}</td></tr>
<tr class="memdesc:a6af95161efed3b4fa5394ec8038aeb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>kDepthMaxMateLen</code> の 16 ビット版 <br /></td></tr>
<tr class="separator:a6af95161efed3b4fa5394ec8038aeb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2480bba5d56dae8e9e7aef05b586261e"><td class="memItemLeft" align="right" valign="top"><a id="a2480bba5d56dae8e9e7aef05b586261e"></a>
constexpr <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a2480bba5d56dae8e9e7aef05b586261e">kMinus1MateLen16</a> = <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>{<a class="el" href="namespacekomori.html#a197ec11c83aea5b797450b5c08e31279">kMinus1MateLen</a>}</td></tr>
<tr class="memdesc:a2480bba5d56dae8e9e7aef05b586261e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>kMinus1MateLen</code> の 16 ビット版 <br /></td></tr>
<tr class="separator:a2480bba5d56dae8e9e7aef05b586261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb649f274998b8caa9f9adb6149f12"><td class="memItemLeft" align="right" valign="top"><a id="a89eb649f274998b8caa9f9adb6149f12"></a>
constexpr <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a89eb649f274998b8caa9f9adb6149f12">kDepthMaxPlus1MateLen16</a> = <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">MateLen16</a>{<a class="el" href="namespacekomori.html#aae8622a1e13915d6e31f36e1541066ce">kDepthMaxPlus1MateLen</a>}</td></tr>
<tr class="memdesc:a89eb649f274998b8caa9f9adb6149f12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>kDepthMaxPlus1MateLen</code> の 16 ビット版 <br /></td></tr>
<tr class="separator:a89eb649f274998b8caa9f9adb6149f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f030c8ad87ebc6e360638a20ca8d707"><td class="memItemLeft" align="right" valign="top"><a id="a2f030c8ad87ebc6e360638a20ca8d707"></a>
constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a2f030c8ad87ebc6e360638a20ca8d707">kExecuteGcHashRate</a> = 0.5</td></tr>
<tr class="memdesc:a2f030c8ad87ebc6e360638a20ca8d707"><td class="mdescLeft">&#160;</td><td class="mdescRight">GC をするタイミング。置換表使用率がこの値を超えていたら GC を行う。 <br /></td></tr>
<tr class="separator:a2f030c8ad87ebc6e360638a20ca8d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a78600b221776f63a4ed34a219006"><td class="memItemLeft" align="right" valign="top"><a id="a525a78600b221776f63a4ed34a219006"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a525a78600b221776f63a4ed34a219006">kExecuteGcHashfullThreshold</a> = std::max(static_cast&lt;int&gt;(1000 * <a class="el" href="namespacekomori.html#a2f030c8ad87ebc6e360638a20ca8d707">kExecuteGcHashRate</a>), 1)</td></tr>
<tr class="memdesc:a525a78600b221776f63a4ed34a219006"><td class="mdescLeft">&#160;</td><td class="mdescRight">GC をする Hashfull のしきい値 <br /></td></tr>
<tr class="separator:a525a78600b221776f63a4ed34a219006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1566dce8d7bbeb1e6bad5be02fd99009"><td class="memItemLeft" align="right" valign="top"><a id="a1566dce8d7bbeb1e6bad5be02fd99009"></a>
thread_local std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a1566dce8d7bbeb1e6bad5be02fd99009">tl_thread_id</a> = 0</td></tr>
<tr class="memdesc:a1566dce8d7bbeb1e6bad5be02fd99009"><td class="mdescLeft">&#160;</td><td class="mdescRight">自分の thread id <br /></td></tr>
<tr class="separator:a1566dce8d7bbeb1e6bad5be02fd99009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f6e43ba7f9cbef8d324f18914c9082"><td class="memItemLeft" align="right" valign="top"><a id="a13f6e43ba7f9cbef8d324f18914c9082"></a>
thread_local bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a13f6e43ba7f9cbef8d324f18914c9082">tl_gc_thread</a> = false</td></tr>
<tr class="memdesc:a13f6e43ba7f9cbef8d324f18914c9082"><td class="mdescLeft">&#160;</td><td class="mdescRight">自分は GC 担当スレッドかどうか <br /></td></tr>
<tr class="separator:a13f6e43ba7f9cbef8d324f18914c9082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28c3e91f330fe95ecf24570473e6a08"><td class="memItemLeft" align="right" valign="top"><a id="ae28c3e91f330fe95ecf24570473e6a08"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae28c3e91f330fe95ecf24570473e6a08">kMaxCheckMovesPerNode</a> = 110</td></tr>
<tr class="memdesc:ae28c3e91f330fe95ecf24570473e6a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">1局面の最大王手/王手回避の着手数 <br /></td></tr>
<tr class="separator:ae28c3e91f330fe95ecf24570473e6a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac939d98950f0320e5694ced139d4c8e0"><td class="memItemLeft" align="right" valign="top"><a id="ac939d98950f0320e5694ced139d4c8e0"></a>
constexpr Depth&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ac939d98950f0320e5694ced139d4c8e0">kDepthMax</a> = 4000</td></tr>
<tr class="memdesc:ac939d98950f0320e5694ced139d4c8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">詰将棋の最大手数。ミクロコスモス（1525手詰）より十分大きな値を設定する <br /></td></tr>
<tr class="separator:ac939d98950f0320e5694ced139d4c8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210e0bb519f465c1516790e741bda731"><td class="memItemLeft" align="right" valign="top"><a id="a210e0bb519f465c1516790e741bda731"></a>
constexpr Hand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a210e0bb519f465c1516790e741bda731">kNullHand</a> = Hand{HAND_BORROW_MASK}</td></tr>
<tr class="memdesc:a210e0bb519f465c1516790e741bda731"><td class="mdescLeft">&#160;</td><td class="mdescRight">無効な持ち駒 <br /></td></tr>
<tr class="separator:a210e0bb519f465c1516790e741bda731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ee19c9520e168d882df693b6566a9b"><td class="memItemLeft" align="right" valign="top"><a id="a69ee19c9520e168d882df693b6566a9b"></a>
constexpr Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a69ee19c9520e168d882df693b6566a9b">kNullKey</a> = Key{0x3343343343343340ULL}</td></tr>
<tr class="memdesc:a69ee19c9520e168d882df693b6566a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">無効な Key <br /></td></tr>
<tr class="separator:a69ee19c9520e168d882df693b6566a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c6a28d0272596fcb24312758455681"><td class="memItemLeft" align="right" valign="top"><a id="a26c6a28d0272596fcb24312758455681"></a>
constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#a26c6a28d0272596fcb24312758455681">kInfinitePnDn</a> = std::numeric_limits&lt;<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&gt;::max() / 2 - 1</td></tr>
<tr class="memdesc:a26c6a28d0272596fcb24312758455681"><td class="mdescLeft">&#160;</td><td class="mdescRight">pn/dn の最大値。オーバーフローを避けるために、max() より少し小さな値を設定する。 <br /></td></tr>
<tr class="separator:a26c6a28d0272596fcb24312758455681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae827eafdb768dc1d7ee921cf9a345694"><td class="memItemLeft" align="right" valign="top"><a id="ae827eafdb768dc1d7ee921cf9a345694"></a>
constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomori.html#ae827eafdb768dc1d7ee921cf9a345694">kPnDnUnit</a> = 2</td></tr>
<tr class="memdesc:ae827eafdb768dc1d7ee921cf9a345694"><td class="mdescLeft">&#160;</td><td class="mdescRight">pn/dn 値の単位。df-pn+ では「評価値0.5」のような小数を扱いたいので1より大きな値を用いれるようにする。 <br /></td></tr>
<tr class="separator:ae827eafdb768dc1d7ee921cf9a345694"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Komoring Heights. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a55fb0edd05205e09790d1b3f440dc196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fb0edd05205e09790d1b3f440dc196">&#9670;&nbsp;</a></span>Constraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekomori.html#a55fb0edd05205e09790d1b3f440dc196">komori::Constraints</a> = typedef typename <a class="el" href="structkomori_1_1detail_1_1_constraints_impl.html">detail::ConstraintsImpl</a>&lt;Args...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE の制約を書くのに便利な型。 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td><code>std::enable_if_t</code> の列。</td></tr>
  </table>
  </dd>
</dl>
<p><code>Args...</code> の中で <code>std::enable_if_t</code> による SFINAE 制約式を書くことができる。制約式がすべて真の場合に限り、 <code>Args...</code> の推論に成功し <code>std::nullptr_t</code> となる。</p>
<p>例）型 <code>T</code> がデフォルト構築可能なときに限り <code>Func()</code> を定義したいとき。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</div>
<div class="line">   Constraints&lt;std::enable_if_t&lt;std::is_default_constructible_v&lt;U&gt;&gt;&gt; = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> Func(T t) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00052">52</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2c3856a7c53116227693f8dcca64199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c3856a7c53116227693f8dcca64199">&#9670;&nbsp;</a></span>MateLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">komori::MateLen</a> = typedef <a class="el" href="classkomori_1_1detail_1_1_mate_len_impl.html">detail::MateLenImpl</a>&lt;std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>詰み／不詰手数 </p>
<p><code>kZeroMateLen</code> 以上 <code>kDepthMaxMateLen</code> 手以下の詰み手数を管理する。内部的には -1 手詰め（<code>kMinus1MateLen</code>）を 表現できるようになっている。</p>
<p>範囲外の初期値がほしい場合は、<code>kMinus1MateLen</code> や <code>kDepthMaxPlus1MateLen</code> を用いる。 </p>

<p class="definition">Definition at line <a class="el" href="mate__len_8hpp_source.html#l00124">124</a> of file <a class="el" href="mate__len_8hpp_source.html">mate_len.hpp</a>.</p>

</div>
</div>
<a id="a5b173701f7efb9de640cd66a993a0af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b173701f7efb9de640cd66a993a0af2">&#9670;&nbsp;</a></span>MateLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekomori.html#a5b173701f7efb9de640cd66a993a0af2">komori::MateLen16</a> = typedef <a class="el" href="classkomori_1_1detail_1_1_mate_len_impl.html">detail::MateLenImpl</a>&lt;std::uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>詰み／不詰手数（<code>MateLen</code> の16ビット版） </p>
<p>実はエンジン全体で <code>MateLen16</code> を使ってもパフォーマンス的にはそれほど影響ないのだが、いつか最終局面の駒あまり枚数を 考慮したくなった時に差が出るかもしれないので、型をちゃんと使い分ける。 </p>

<p class="definition">Definition at line <a class="el" href="mate__len_8hpp_source.html#l00132">132</a> of file <a class="el" href="mate__len_8hpp_source.html">mate_len.hpp</a>.</p>

</div>
</div>
<a id="ae2b179f7c8adb463807f13c9d73ec34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b179f7c8adb463807f13c9d73ec34a">&#9670;&nbsp;</a></span>PnDn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">komori::PnDn</a> = typedef std::uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>証明数／反証数を格納する型 </p>
<p>32ビット整数だとすぐにオーバーフローしてしまうので、64ビット整数を用いる。 </p>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00194">194</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ada1a4eeb6080f15a12a946bf93ff7488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1a4eeb6080f15a12a946bf93ff7488">&#9670;&nbsp;</a></span>NodeState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekomori.html#ada1a4eeb6080f15a12a946bf93ff7488">komori::NodeState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>局面の探索状態。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada1a4eeb6080f15a12a946bf93ff7488a25c2dc47991b3df171ed5192bcf70390"></a>kUnknown&#160;</td><td class="fielddoc"><p>不明（探索中） </p>
</td></tr>
<tr><td class="fieldname"><a id="ada1a4eeb6080f15a12a946bf93ff7488a91941e19d11188fa06c946a61bef1d7d"></a>kProven&#160;</td><td class="fielddoc"><p>詰み </p>
</td></tr>
<tr><td class="fieldname"><a id="ada1a4eeb6080f15a12a946bf93ff7488ac07a394d06065193a8cbf2f53000b916"></a>kDisproven&#160;</td><td class="fielddoc"><p>千日手ではない不詰 </p>
</td></tr>
<tr><td class="fieldname"><a id="ada1a4eeb6080f15a12a946bf93ff7488a0da05df76ef6b213939d96600064949d"></a>kRepetition&#160;</td><td class="fielddoc"><p>千日手による不詰 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00182">182</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="a0f8bac3d10dabcca8f1933216eb2d7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8bac3d10dabcca8f1933216eb2d7f0">&#9670;&nbsp;</a></span>PostSearchLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekomori.html#a0f8bac3d10dabcca8f1933216eb2d7f0">komori::PostSearchLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>余詰探索の度合い。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f8bac3d10dabcca8f1933216eb2d7f0a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>余詰探索なし </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f8bac3d10dabcca8f1933216eb2d7f0a653007906d4d1c6cd05c5517dff4786e"></a>kUpperBound&#160;</td><td class="fielddoc"><p>Upper bound に一致する長さの手順を見つけるまで </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f8bac3d10dabcca8f1933216eb2d7f0afde98040dc0c46ca54b30798d8190c54"></a>kMinLength&#160;</td><td class="fielddoc"><p>最短手順を探す </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00027">27</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<a id="adc4d7ccfd98577a6c7e7d9830b9add11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d7ccfd98577a6c7e7d9830b9add11">&#9670;&nbsp;</a></span>ScoreCalculationMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekomori.html#adc4d7ccfd98577a6c7e7d9830b9add11">komori::ScoreCalculationMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>評価値の計算方法。詰将棋エンジンでは評価値を計算する決まった方法がないので選べるようにしておく。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adc4d7ccfd98577a6c7e7d9830b9add11a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>詰み／不詰が確定するまで評価値を表示しない </p>
</td></tr>
<tr><td class="fieldname"><a id="adc4d7ccfd98577a6c7e7d9830b9add11a3a603030c47fb8af0037af651f00e110"></a>kDn&#160;</td><td class="fielddoc"><p>dnをそのまま評価値として出す </p>
</td></tr>
<tr><td class="fieldname"><a id="adc4d7ccfd98577a6c7e7d9830b9add11a90342bf1b782eb2a96b24391f4f61693"></a>kMinusPn&#160;</td><td class="fielddoc"><p>-pnをそのまま評価値として出す </p>
</td></tr>
<tr><td class="fieldname"><a id="adc4d7ccfd98577a6c7e7d9830b9add11a236068ef7962d525e144dcb55732165d"></a>kPonanza&#160;</td><td class="fielddoc"><p>ポナンザ定数を用いた勝率 &lt;-&gt; 評価値変換 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="engine__option_8hpp_source.html#l00017">17</a> of file <a class="el" href="engine__option_8hpp_source.html">engine_option.hpp</a>.</p>

</div>
</div>
<a id="a7f5d6d57beee6813c2cf957fab95cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d6d57beee6813c2cf957fab95cd53">&#9670;&nbsp;</a></span>UsiInfoKey</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekomori.html#a7f5d6d57beee6813c2cf957fab95cd53">komori::UsiInfoKey</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classkomori_1_1_usi_info.html#abc0d87a921059d9c1a503e390eb2f0e3" title="key に val を設定する。">UsiInfo::Set()</a></code> で設定可能なUSIオプション一覧 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53af588847884f09f744af48ef8d9a0eda8"></a>kSelDepth&#160;</td><td class="fielddoc"><p>選択的探索深さ </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a4fbae144eab5d83a51adcf4d6542805a"></a>kTime&#160;</td><td class="fielddoc"><p>探索時間（ms） </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a160413698c72c216b33f26d67f394d26"></a>kNodes&#160;</td><td class="fielddoc"><p>探索局面数 </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a98d4711a6e938752ae25d67a5de61391"></a>kNps&#160;</td><td class="fielddoc"><p>探索速度 </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a709f077202ab7f8fac38e174044968b9"></a>kHashfull&#160;</td><td class="fielddoc"><p>置換表の使用率（千分率） </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a01b0b332aabe7b2d016322deab8b3aea"></a>kCurrMove&#160;</td><td class="fielddoc"><p>現在の最善手 </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f5d6d57beee6813c2cf957fab95cd53a42cd9f8462e879f12a7bdddfb5743080"></a>kScore&#160;</td><td class="fielddoc"><p>現在の評価値。PVがセットされているときは効果がないので注意。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="usi__info_8hpp_source.html#l00019">19</a> of file <a class="el" href="usi__info_8hpp_source.html">usi_info.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abe78bf2e5661e6a5459917ea76c2d560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe78bf2e5661e6a5459917ea76c2d560">&#9670;&nbsp;</a></span>AddIfHandGivesOtherEvasions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Hand komori::AddIfHandGivesOtherEvasions </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hand&#160;</td>
          <td class="paramname"><em>proof_hand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>局面 n の子局面がすべて証明駒 proof_hand で詰みであることが既知の場合、もとの局面 n の証明駒を計算する。 </p>
<p>AndNode の時に限り呼び出せる。 proof_hand をそのまま返すのが基本だが、もし proof_hand の中に局面 n では持っていない駒が含まれていた場合、 その駒を打って合駒をすれば詰みを防げたかもしれない。（局面 n に含まれないので、前提となる子局面の探索には含まれない） そのため、現局面で持っていない種別の持ち駒がある場合は、証明駒に加える（合駒がなかった情報を付与する）必要がある。</p>
<h3><a class="anchor" id="autotoc_md1"></a>
例</h3>
<div class="fragment"><div class="line">後手の持駒：香</div>
<div class="line">  ９ ８ ７ ６ ５ ４ ３ ２ １</div>
<div class="line">+---------------------------+</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|一</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|二</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|三</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・v香 ・|四</div>
<div class="line">|v金v銀v角v桂 ・ ・ ・v歩v玉|五</div>
<div class="line">|v角v飛v飛v桂 ・ ・ ・v香 ・|六</div>
<div class="line">|v桂v桂v金 ・ ・ ・ ・ ・ ・|七</div>
<div class="line">|v銀v銀v銀 ・ ・ ・ ・ と ・|八</div>
<div class="line">|v金v金 ・ ・ ・ ・ ・ ・ 香|九</div>
<div class="line">+---------------------------+</div>
<div class="line">先手の持駒：歩十六</div>
</div><!-- fragment --><p>↑後手の合駒が悪いので詰んでしまう。つまり、「先手が歩を独占している」という情報も証明駒に含める必要がある。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現在の局面 </td></tr>
    <tr><td class="paramname">proof_hand</td><td>n に対する子局面の探索で得られた証明駒の極小集合 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hand proof_hand から n で受け方が持っていない　かつ　合駒で王手を防げる持ち駒を攻め方側に集めた持ち駒 </dd></dl>

<p class="definition">Definition at line <a class="el" href="hands_8hpp_source.html#l00193">193</a> of file <a class="el" href="hands_8hpp_source.html">hands.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_abe78bf2e5661e6a5459917ea76c2d560_cgraph.png" border="0" usemap="#anamespacekomori_abe78bf2e5661e6a5459917ea76c2d560_cgraph" alt=""/></div>
<map name="anamespacekomori_abe78bf2e5661e6a5459917ea76c2d560_cgraph" id="anamespacekomori_abe78bf2e5661e6a5459917ea76c2d560_cgraph">
<area shape="rect" title="局面 n の子局面がすべて証明駒 proof_hand で詰みであることが既知の場合、もとの局面 n の証明駒を計算する。" alt="" coords="5,23,221,65"/>
<area shape="rect" href="namespacekomori.html#a910cf44bbf31dae9af184770f7ca5dd4" title="2 つの持ち駒を 1 つにまとめる" alt="" coords="275,5,426,32"/>
<area shape="rect" href="namespacekomori.html#a48f3fa8cf78887150c3558bf0ebbf47c" title="hand から pr を消す" alt="" coords="269,56,432,83"/>
</map>
</div>

</div>
</div>
<a id="a02f36bba9f6289806c06f00e2c8581cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f36bba9f6289806c06f00e2c8581cc">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>範囲 <code>range</code> に対して関数 <code>func</code> をそれぞれ適用したような範囲を返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>範囲 </td></tr>
    <tr><td class="paramname">func</td><td>適用する関数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>範囲 <code>range</code> に対して関数 <code>func</code> をそれぞれ適用したような範囲 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00503">503</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="a2b91824ee210b1157a170f0b0dc650cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b91824ee210b1157a170f0b0dc650cb">&#9670;&nbsp;</a></span>ApplyDeltaHand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Hand komori::ApplyDeltaHand </td>
          <td>(</td>
          <td class="paramtype">Hand&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hand&#160;</td>
          <td class="paramname"><em>diff_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hand&#160;</td>
          <td class="paramname"><em>diff_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持ち駒 <code>target</code> に <code>diff_dst - diff_src</code> を加える </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>現在の持ち駒 </td></tr>
    <tr><td class="paramname">diff_src</td><td>変化量の起点 </td></tr>
    <tr><td class="paramname">diff_dst</td><td>変化量の終点 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>target</code> に <code>diff_dst - diff_src</code> を加算した結果 </dd></dl>

<p class="definition">Definition at line <a class="el" href="hands_8hpp_source.html#l00083">83</a> of file <a class="el" href="hands_8hpp_source.html">hands.hpp</a>.</p>

</div>
</div>
<a id="a8e1493fa709128d5d926e1809323c633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1493fa709128d5d926e1809323c633">&#9670;&nbsp;</a></span>AsRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto komori::AsRange </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; Iterator, Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>イテレータのペアで range-based for をするためのアダプタ </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>イテレータ</td></tr>
  </table>
  </dd>
</dl>
<p><code>std::multimap::equal_range()</code> のように、(begin, end) の形式のイテレータを所持しているとき、range-based for で 要素を取り出すためのアダプタ。</p>
<div class="fragment"><div class="line">std::unordered_multimap&lt;std::int32_t, std::int32_t&gt; map{ ... };</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : <a class="code" href="namespacekomori.html#a8e1493fa709128d5d926e1809323c633">AsRange</a>(map.equal_range(10))) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="anamespacekomori_html_a8e1493fa709128d5d926e1809323c633"><div class="ttname"><a href="namespacekomori.html#a8e1493fa709128d5d926e1809323c633">komori::AsRange</a></div><div class="ttdeci">auto AsRange(const std::pair&lt; Iterator, Iterator &gt; &amp;p) noexcept</div><div class="ttdoc">イテレータのペアで range-based for をするためのアダプタ</div><div class="ttdef"><b>Definition:</b> <a href="ranges_8hpp_source.html#l00246">ranges.hpp:246</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00246">246</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="af60b97ffafc4e100347e046e86ef02ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60b97ffafc4e100347e046e86ef02ac">&#9670;&nbsp;</a></span>CheckMate1Ply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Move, Hand&gt; komori::CheckMate1Ply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(OR node限定) <code>n</code> が 1 手詰かどうか判定する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Move</code> 1手詰があればその手。なければ <code>MOVE_NONE</code>。 </dd>
<dd>
<code>Hand</code> 1手詰があればその証明駒。なければ <code>kNullHand</code>。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>攻め方の玉に王手がかかっている等、一部局面では1手詰が見つけられない事がある。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00221">221</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_af60b97ffafc4e100347e046e86ef02ac_cgraph.png" border="0" usemap="#anamespacekomori_af60b97ffafc4e100347e046e86ef02ac_cgraph" alt=""/></div>
<map name="anamespacekomori_af60b97ffafc4e100347e046e86ef02ac_cgraph" id="anamespacekomori_af60b97ffafc4e100347e046e86ef02ac_cgraph">
<area shape="rect" title="(OR node限定) n が 1 手詰かどうか判定する。" alt="" coords="5,111,181,137"/>
<area shape="rect" href="namespacekomori.html#ace83f8e2ffff818bd25b6def2e075904" title="move 後の手駒が after_hand のとき、移動前の持ち駒を返す" alt="" coords="247,5,399,32"/>
<area shape="rect" href="classkomori_1_1_node.html#a082d5d0045420c8978206fda2b518e17" title="move で1手進める" alt="" coords="237,195,408,221"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="754,224,894,251"/>
<area shape="rect" href="classkomori_1_1_node.html#aad7fe2734b150a1d9645ea72e2fdda83" title="DoMove() で進めた局面を元に戻す" alt="" coords="229,367,416,393"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a5f9f4c0e10424bb96f652c18cfc6afc7" title="スタックの末尾（最も後に保存した要素）" alt="" coords="484,275,656,317"/>
<area shape="rect" href="classkomori_1_1_node.html#afc3ff609d7a14aae03aab36317148f63" title="現在の盤面ハッシュ値" alt="" coords="481,341,659,368"/>
<area shape="rect" href="classkomori_1_1_node.html#a2c10b9d22f4966f51b47495088f4fd4b" title="現在の攻め方の持ち駒" alt="" coords="487,224,653,251"/>
<area shape="rect" href="classkomori_1_1_node.html#a6dfeb2e63ce33d5b9043010cbb8428c3" title="move 後の経路ハッシュ値" alt="" coords="724,89,924,116"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a122fd54c4b21ad3d1ce129cf1b2d6f3f" title="val をスタックに追加する" alt="" coords="484,158,656,199"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a3ba89e53fbe90e03b07b2c68eea98334" title="(board_key, hand) を履歴に登録する" alt="" coords="495,443,645,485"/>
<area shape="rect" href="namespacekomori.html#ae0ab7ef1101897b620e05208fc8975ee" title="現在の path_key と手 move から1手後の path_key を計算する。" alt="" coords="972,420,1131,447"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a62769876f5547de5b474300c666cea8a" title="index の次のインデックスを求める" alt="" coords="749,469,899,510"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#ab3ed82ca4c526f4f34c90c9277ba7d5b" title="board_key に対する探索開始インデックスを求める" alt="" coords="749,541,899,582"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a3af0755f672c9b15c72253aebc682aa5" title="(board_key, hand) を履歴から消す" alt="" coords="495,561,645,602"/>
<area shape="rect" href="classkomori_1_1_node.html#a7f1c13d7f57b6af7f34ac77240342d71" title="move 直前の経路ハッシュ値" alt="" coords="464,627,676,653"/>
<area shape="rect" href="classkomori_1_1_fixed_size_stack.html#a30a23ee0ab5980d4fad72185cafed9d0" title="スタックから要素を1つ削除する" alt="" coords="468,509,672,536"/>
<area shape="rect" href="namespacekomori.html#af65c288516ec71f448f2947aac9e755b" title="1手後の path_key と手 move から現在の path_key を計算する。" alt="" coords="739,620,909,647"/>
</map>
</div>

</div>
</div>
<a id="a177c33b9356030cab989f275b6fd6ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c33b9356030cab989f275b6fd6ea4">&#9670;&nbsp;</a></span>ClampPnDn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> komori::ClampPnDn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>max</em> = <code><a class="el" href="namespacekomori.html#a26c6a28d0272596fcb24312758455681">kInfinitePnDn</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pn/dn の値を [<code>min</code>, <code>max</code>] の範囲に収まるように丸める。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>pnまたはdn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>範囲の最小値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>範囲の最大値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PnDn [<code>min</code>, <code>max</code>] の範囲に丸めた <code>val</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00206">206</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="a27ad9df4bbd3b788096fc2b47251524a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad9df4bbd3b788096fc2b47251524a">&#9670;&nbsp;</a></span>ConsumeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void komori::ConsumeValues </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structkomori_1_1detail_1_1_anything.html">detail::Anything</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任意の値を虚無に送る関数 </p>
<p><code>Anything</code> 型の初期化子リストを引数に取り、何もしない関数。<code>Anything</code> 型は任意の値でコンストラクト可能なので、 この関数は任意の値を捨てるために用いることができる。</p>
<p>例えば、式 expr の評価だけして結果をどこかへ捨てたい場合、</p>
<div class="fragment"><div class="line"><a class="code" href="namespacekomori.html#a27ad9df4bbd3b788096fc2b47251524a">ConsumeValues</a>({expr});</div>
<div class="ttc" id="anamespacekomori_html_a27ad9df4bbd3b788096fc2b47251524a"><div class="ttname"><a href="namespacekomori.html#a27ad9df4bbd3b788096fc2b47251524a">komori::ConsumeValues</a></div><div class="ttdeci">constexpr void ConsumeValues(std::initializer_list&lt; detail::Anything &gt;) noexcept</div><div class="ttdoc">任意の値を虚無に送る関数</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8hpp_source.html#l00137">type_traits.hpp:137</a></div></div>
</div><!-- fragment --><p>と書ける。また、式が複数個ある場合は、</p>
<div class="fragment"><div class="line"><a class="code" href="namespacekomori.html#a27ad9df4bbd3b788096fc2b47251524a">ConsumeValues</a>({expr1, expr2, ...});</div>
</div><!-- fragment --><p>と書く。 </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00137">137</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a9b03d373bf7f539b7a9d8d0df9a61669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b03d373bf7f539b7a9d8d0df9a61669">&#9670;&nbsp;</a></span>Delta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> komori::Delta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>dn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>or_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>δ値を計算する。現局面が <code>or_node</code> なら <code>dn</code>, そうでないなら <code>pn</code> を返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pn</td><td>pn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dn</td><td>dn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">or_node</td><td>現局面が OR <a class="el" href="classkomori_1_1_node.html" title="Position をラップして詰将棋特有の判定を追加するクラス。">Node</a> なら <code>true</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PnDn δ値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00228">228</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="afa08995342dc8f460d6de738cd457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa08995342dc8f460d6de738cd457571">&#9670;&nbsp;</a></span>DoesHaveMatePossibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool komori::DoesHaveMatePossibility </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(OR node限定) <code>n</code> が不詰かどうかを簡易的に調べる。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面（OR node） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>: 不明 </dd>
<dd>
<code>false</code>: 確実に不詰</dd></dl>
<p>指し手生成をすることなく <code>n</code> の合法手がない、すなわち不詰局面かどうかを判定する。<code>generateMoves</code> よりも 厳密性は劣るが、より高速に不詰を判定できる可能性がある。</p>
<p>この関数の戻り値が <code>false</code> のとき、<code>n</code> には合法手が存在しない。戻り値が <code>true</code> のとき、不詰かどうかは不明である。 戻り値が <code>true</code> であっても、現局面に合法手が存在しない可能性があるので注意。 </p>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00310">310</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="aa8a333a0a9dfda36b2fc53731711e1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a333a0a9dfda36b2fc53731711e1f3">&#9670;&nbsp;</a></span>FindKnownAncestor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structkomori_1_1_branch_root_edge.html">BranchRootEdge</a>&gt; komori::FindKnownAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekomori_1_1tt.html#ab367c034eba59afd3939578f638b0ffb">tt::TranspositionTable</a> &amp;&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>n</code> を <code>move</code> した局面から置換表をたどると <code>n</code> の祖先に行き着くかどうか調べる </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tt</td><td>置換表 </td></tr>
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
    <tr><td class="paramname">move</td><td>次の手 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>見つけた場合はその分岐元の辺。なければ <code>std::nullopt</code>。</dd></dl>
<p><code>n</code> を <code>move</code> で進めた局面を起点に、<code>tt</code> に書かれた親局面をたどる。たどった結果 <code>n</code> の先祖局面に合流するかどうかを 判定し、見つけた合流元局面から分岐する辺 <code><a class="el" href="structkomori_1_1_branch_root_edge.html" title="二重カウントの可能性がある辺。 FindKnownAncestor の戻り値に用いる。">BranchRootEdge</a></code> を返す。イメージ図を以下に示す</p>
<div class="fragment"><div class="line">                              Node</div>
<div class="line">        ^ BranchRootEdge --&gt; /    \               |</div>
<div class="line">        |                  Node  Node             |</div>
<div class="line">        |                   |     |               |</div>
<div class="line">TT Path |                   .     .               | Current Search Path</div>
<div class="line">        |                   |     |               |</div>
<div class="line">        |                   |   Node &lt;-- n        |</div>
<div class="line">        |                   \    / &lt;-- move       |</div>
<div class="line">        |                    Node                 v</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="double__count__elimination_8hpp_source.html#l00102">102</a> of file <a class="el" href="double__count__elimination_8hpp_source.html">double_count_elimination.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_aa8a333a0a9dfda36b2fc53731711e1f3_cgraph.png" border="0" usemap="#anamespacekomori_aa8a333a0a9dfda36b2fc53731711e1f3_cgraph" alt=""/></div>
<map name="anamespacekomori_aa8a333a0a9dfda36b2fc53731711e1f3_cgraph" id="anamespacekomori_aa8a333a0a9dfda36b2fc53731711e1f3_cgraph">
<area shape="rect" title="n を move した局面から置換表をたどると n の祖先に行き着くかどうか調べる" alt="" coords="5,267,208,293"/>
<area shape="rect" href="classkomori_1_1_node.html#ae8e8fe23b128f7ae53c3878437828caa" title="move 後の盤面ハッシュ値と攻め方の持ち駒を同時に取得する" alt="" coords="256,91,469,133"/>
<area shape="rect" href="classkomori_1_1_node.html#a4340f73789f45570ffe593fc9d0aafa9" title="現在 OR node かどうか" alt="" coords="781,157,958,184"/>
<area shape="rect" href="classkomori_1_1tt_1_1detail_1_1_transposition_table_impl.html#ad0d9e65f7b1603b063cd8d3c7252a797" title="生のハッシュ値からクエリを構築する" alt="" coords="273,317,452,373"/>
<area shape="rect" href="classkomori_1_1_node.html#a518389ecf55b16ebf8f41dcb8c5ff731" title="(board_key, hand) が経路に含まれているかどうか" alt="" coords="517,275,732,301"/>
<area shape="rect" href="classkomori_1_1_node.html#a1e4f1da48b69fb3356543b7cf37aab12" title="盤面ハッシュ値と攻め方の持ち駒を同時に取得する" alt="" coords="523,209,726,250"/>
<area shape="rect" href="classkomori_1_1_node.html#a19fbde5adf6e542e61f6c620df5b4d16" title="現在の探索深さ" alt="" coords="273,397,452,424"/>
<area shape="rect" href="classkomori_1_1tt_1_1_query.html#ae11cf79d33310475e709b3001a39ee63" title="置換表に保存された現局面の親局面を取得する" alt="" coords="293,449,432,490"/>
<area shape="rect" href="classkomori_1_1_node.html#ab47757b0ecd5c40af2b2246a17477a13" title="move 後の盤面ハッシュ値" alt="" coords="1007,5,1217,32"/>
<area shape="rect" href="classkomori_1_1_node.html#ac82d1552c36647cc88e62b104b77595d" title="move 後の攻め方の持ち駒" alt="" coords="526,107,723,133"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="1265,157,1405,184"/>
<area shape="rect" href="namespacekomori.html#ae5838f0a6fe258eb2bc0197498cd7358" title="move 後の手駒を返す" alt="" coords="799,107,939,133"/>
<area shape="rect" href="classkomori_1_1_node.html#a2c10b9d22f4966f51b47495088f4fd4b" title="現在の攻め方の持ち駒" alt="" coords="786,208,953,235"/>
<area shape="rect" href="classkomori_1_1_node.html#acd0ed0838fa087e459aadae9cf563b0c" title="現在の手番" alt="" coords="1045,157,1179,184"/>
<area shape="rect" href="classkomori_1_1tt_1_1_regular_table.html#aa6ac86c8e1152cbe7a18e8d81a55fcef" title="board_key に対応する循環領域へのポインタを取得する" alt="" coords="536,326,713,367"/>
<area shape="rect" href="classkomori_1_1_node.html#afc3ff609d7a14aae03aab36317148f63" title="現在の盤面ハッシュ値" alt="" coords="780,259,959,285"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a5b2e24143732a4396cc526be6aac0196" title="(board_key, hand) の同一局面が履歴に記録されているか調べる。" alt="" coords="794,310,945,351"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#a62769876f5547de5b474300c666cea8a" title="index の次のインデックスを求める" alt="" coords="1037,310,1187,351"/>
<area shape="rect" href="classkomori_1_1_visit_history.html#ab3ed82ca4c526f4f34c90c9277ba7d5b" title="board_key に対する探索開始インデックスを求める" alt="" coords="1037,375,1187,417"/>
<area shape="rect" href="classkomori_1_1tt_1_1_entry.html#af1969c3d079ea4a462df415e5ce4ec1b" title="エントリが未使用状態かを判定する。この関数に限っては共有ロックを取得せずに使用することができる。" alt="" coords="557,449,692,490"/>
</map>
</div>

</div>
</div>
<a id="a0674ce184ef6aec644ffb45a0b021bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0674ce184ef6aec644ffb45a0b021bb5">&#9670;&nbsp;</a></span>InitBriefEvaluation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void komori::InitBriefEvaluation </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初期評価値を乱数でずらす </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>スレッド番号 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00048">48</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>

</div>
</div>
<a id="afb92abe1c44b30904f85796fd729b87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb92abe1c44b30904f85796fd729b87e">&#9670;&nbsp;</a></span>InitializeThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void komori::InitializeThread </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thread local 変数を初期化する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>自身の thread id </td></tr>
    <tr><td class="paramname">num_threads</td><td>スレッド数</td></tr>
  </table>
  </dd>
</dl>
<p>thread local 変数たちを初期化する。探索開始前に呼び出すこと。 </p>

<p class="definition">Definition at line <a class="el" href="thread__initialization_8hpp_source.html#l00019">19</a> of file <a class="el" href="thread__initialization_8hpp_source.html">thread_initialization.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_afb92abe1c44b30904f85796fd729b87e_cgraph.png" border="0" usemap="#anamespacekomori_afb92abe1c44b30904f85796fd729b87e_cgraph" alt=""/></div>
<map name="anamespacekomori_afb92abe1c44b30904f85796fd729b87e_cgraph" id="anamespacekomori_afb92abe1c44b30904f85796fd729b87e_cgraph">
<area shape="rect" title="thread local 変数を初期化する" alt="" coords="5,31,181,57"/>
<area shape="rect" href="namespacekomori.html#a0674ce184ef6aec644ffb45a0b021bb5" title="初期評価値を乱数でずらす" alt="" coords="233,5,429,32"/>
<area shape="rect" href="namespacekomori_1_1tt.html#a5412496f8d69289ce41076dad0b8730e" title="LookUp() のノイズ周期を初期化する" alt="" coords="229,56,432,83"/>
</map>
</div>

</div>
</div>
<a id="a5c6a82becf6ccac969ecceaf30f5b95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6a82becf6ccac969ecceaf30f5b95a">&#9670;&nbsp;</a></span>InitialPnDn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>, <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&gt; komori::InitialPnDn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初めて訪れた局面の pn/dn 初期値を計算する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現局面 </td></tr>
    <tr><td class="paramname">move</td><td>次の手 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> を <code>move</code> で動かした局面の pn/dn の初期値</dd></dl>
<p>局面の pn/dn 初期値を与える関数。古典的な df-pn アルゴリズムでは (pn, dn) = (1, 1) だが、この値を 詰みやすさ／詰み逃れやすさに応じて増減させることで探索性能を向上させられる。 </p>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00170">170</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_a5c6a82becf6ccac969ecceaf30f5b95a_cgraph.png" border="0" usemap="#anamespacekomori_a5c6a82becf6ccac969ecceaf30f5b95a_cgraph" alt=""/></div>
<map name="anamespacekomori_a5c6a82becf6ccac969ecceaf30f5b95a_cgraph" id="anamespacekomori_a5c6a82becf6ccac969ecceaf30f5b95a_cgraph">
<area shape="rect" title="初めて訪れた局面の pn/dn 初期値を計算する" alt="" coords="5,129,152,156"/>
<area shape="rect" href="classkomori_1_1_node.html#a19fbde5adf6e542e61f6c620df5b4d16" title="現在の探索深さ" alt="" coords="200,5,379,32"/>
<area shape="rect" href="namespacekomori_1_1detail.html#a56e953984699bd0e99000f56bc96dcb9" title="df&#45;pn+における AND node の pn/dn 初期値を計算する" alt="" coords="203,57,376,98"/>
<area shape="rect" href="namespacekomori_1_1detail.html#a7e8c39e028338e1c24e97418bf751772" title="df&#45;pn+における OR node の pn/dn 初期値を計算する" alt="" coords="203,122,376,163"/>
<area shape="rect" href="classkomori_1_1_node.html#a4340f73789f45570ffe593fc9d0aafa9" title="現在 OR node かどうか" alt="" coords="201,188,378,215"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="609,213,749,240"/>
<area shape="rect" href="classkomori_1_1_node.html#acd0ed0838fa087e459aadae9cf563b0c" title="現在の手番" alt="" coords="427,188,561,215"/>
</map>
</div>

</div>
</div>
<a id="a09690cec75eb5532478fb7cb04aafcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09690cec75eb5532478fb7cb04aafcb8">&#9670;&nbsp;</a></span>IsSumDeltaNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool komori::IsSumDeltaNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move はδ値をsumで計算すべきか／maxで計上すべきかを判定する </p>
<p>似たような子局面になる move が複数ある場合、δ値を定義通りに sum で計算すると局面を過小評価 （実際の値よりも大きく出る）ことがある。そのため、move の内容によっては sum ではなく max でδ値を計上したほうが良い。</p>
<dl class="section return"><dt>Returns</dt><dd>true move に対するδ値は sum で計上すべき </dd>
<dd>
false move に対するδ値は max で計上すべき </dd></dl>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00227">227</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_a09690cec75eb5532478fb7cb04aafcb8_cgraph.png" border="0" usemap="#anamespacekomori_a09690cec75eb5532478fb7cb04aafcb8_cgraph" alt=""/></div>
<map name="anamespacekomori_a09690cec75eb5532478fb7cb04aafcb8_cgraph" id="anamespacekomori_a09690cec75eb5532478fb7cb04aafcb8_cgraph">
<area shape="rect" title="move はδ値をsumで計算すべきか／maxで計上すべきかを判定する" alt="" coords="5,81,189,108"/>
<area shape="rect" href="classkomori_1_1_node.html#af2b9d2ba13ac5a9536d6aa1b618d2753" title="AND node（玉方）の手番" alt="" coords="238,5,414,32"/>
<area shape="rect" href="classkomori_1_1_node.html#a4340f73789f45570ffe593fc9d0aafa9" title="現在 OR node かどうか" alt="" coords="237,56,415,83"/>
<area shape="rect" href="classkomori_1_1_node.html#acd0ed0838fa087e459aadae9cf563b0c" title="現在の手番" alt="" coords="463,107,597,133"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="645,132,785,159"/>
</map>
</div>

</div>
</div>
<a id="a1b7ffdadd3d71c7adb2f85aa0bead587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ffdadd3d71c7adb2f85aa0bead587">&#9670;&nbsp;</a></span>MoveBriefEvaluation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int komori::MoveBriefEvaluation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkomori_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>局面 n の手 move に対するざっくりとした評価値を返す。 </p>
<p>値が小さければ小さいほど（手番側にとって）良い手を表す。 <a class="el" href="classkomori_1_1_move_picker.html" title="詰将棋探索用の指し手生成器">MovePicker</a> において指し手のオーダリングをする際に使う。 </p>

<p class="definition">Definition at line <a class="el" href="initial__estimation_8hpp_source.html#l00194">194</a> of file <a class="el" href="initial__estimation_8hpp_source.html">initial_estimation.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_a1b7ffdadd3d71c7adb2f85aa0bead587_cgraph.png" border="0" usemap="#anamespacekomori_a1b7ffdadd3d71c7adb2f85aa0bead587_cgraph" alt=""/></div>
<map name="anamespacekomori_a1b7ffdadd3d71c7adb2f85aa0bead587_cgraph" id="anamespacekomori_a1b7ffdadd3d71c7adb2f85aa0bead587_cgraph">
<area shape="rect" title="局面 n の手 move に対するざっくりとした評価値を返す。" alt="" coords="5,56,216,83"/>
<area shape="rect" href="classkomori_1_1_node.html#ac55fed283b0bf189c42a5e73f3f1bf3c" title="玉の位置" alt="" coords="264,5,455,32"/>
<area shape="rect" href="classkomori_1_1_node.html#a485678f91b4653d87fcf5ee6071351de" title="このクラスが保持する Position への参照" alt="" coords="521,56,661,83"/>
<area shape="rect" href="classkomori_1_1_node.html#acd0ed0838fa087e459aadae9cf563b0c" title="現在の手番" alt="" coords="292,107,427,133"/>
<area shape="rect" href="classkomori_1_1_node.html#af2b9d2ba13ac5a9536d6aa1b618d2753" title="AND node（玉方）の手番" alt="" coords="503,5,679,32"/>
</map>
</div>

</div>
</div>
<a id="ab4c8398dda0325cc3ecd032c30a01425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c8398dda0325cc3ecd032c30a01425">&#9670;&nbsp;</a></span>OrdinalNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string komori::OrdinalNumber </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>整数 <code>i</code> に対し、序数（Ordinal Number）の文字列を返す </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>整数型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>i</code> の序数表現（1st や 12th など） </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00279">279</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="ae0ab7ef1101897b620e05208fc8975ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab7ef1101897b620e05208fc8975ee">&#9670;&nbsp;</a></span>PathKeyAfter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Key komori::PathKeyAfter </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>path_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Depth&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>現在の <code>path_key</code> と手 <code>move</code> から1手後の <code>path_key</code> を計算する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path_key</td><td>現在の経路ハッシュ値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">move</td><td>次の手 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>現在の探索深さ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key <code>move</code> 後の経路ハッシュ値</dd></dl>
<p>深さ <code>depth</code> により経路ハッシュ値が異なる。<code>depth</code> の値に応じてハッシュ値を変えることで、手順が前後して同じ局面に 至る経路の間でハッシュ値がかぶらないようにしている。 </p>

<p class="definition">Definition at line <a class="el" href="path__keys_8hpp_source.html#l00066">66</a> of file <a class="el" href="path__keys_8hpp_source.html">path_keys.hpp</a>.</p>

</div>
</div>
<a id="a0f2d9c64c7921e22678f953901421109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2d9c64c7921e22678f953901421109">&#9670;&nbsp;</a></span>PathKeyAfterGive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Key komori::PathKeyAfterGive </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>path_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PieceType&#160;</td>
          <td class="paramname"><em>given_pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Depth&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>相手に持ち駒 <code>stolen_pr</code> を1枚プレゼントした後の <code>path_key</code> を計算する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path_key</td><td>現在の経路ハッシュ値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">given_pr</td><td>相手にプレゼントする駒 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>現在の探索深さ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>持ち駒を渡した直後のハッシュ値</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>PathKeyAfterGive</code> は XOR に基づく差分計算をしているため、逆写像も全く同じ関数で実現できる </dd></dl>

<p class="definition">Definition at line <a class="el" href="path__keys_8hpp_source.html#l00121">121</a> of file <a class="el" href="path__keys_8hpp_source.html">path_keys.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_a0f2d9c64c7921e22678f953901421109_cgraph.png" border="0" usemap="#anamespacekomori_a0f2d9c64c7921e22678f953901421109_cgraph" alt=""/></div>
<map name="anamespacekomori_a0f2d9c64c7921e22678f953901421109_cgraph" id="anamespacekomori_a0f2d9c64c7921e22678f953901421109_cgraph">
<area shape="rect" title="相手に持ち駒 stolen_pr を1枚プレゼントした後の path_key を計算する。" alt="" coords="5,5,193,32"/>
<area shape="rect" href="namespacekomori.html#a2cf6683308beb3ccfd868d347e93c8ac" title="相手の持ち駒 stolen_pr を1枚奪った後の path_key を計算する。" alt="" coords="241,5,432,32"/>
</map>
</div>

</div>
</div>
<a id="a2cf6683308beb3ccfd868d347e93c8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6683308beb3ccfd868d347e93c8ac">&#9670;&nbsp;</a></span>PathKeyAfterSteal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Key komori::PathKeyAfterSteal </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>path_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PieceType&#160;</td>
          <td class="paramname"><em>stolen_pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Depth&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>相手の持ち駒 <code>stolen_pr</code> を1枚奪った後の <code>path_key</code> を計算する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path_key</td><td>現在の経路ハッシュ値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stolen_pr</td><td>相手の持ち駒から奪う駒 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>現在の探索深さ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>持ち駒を奪った直後のハッシュ値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="path__keys_8hpp_source.html#l00108">108</a> of file <a class="el" href="path__keys_8hpp_source.html">path_keys.hpp</a>.</p>

</div>
</div>
<a id="af65c288516ec71f448f2947aac9e755b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65c288516ec71f448f2947aac9e755b">&#9670;&nbsp;</a></span>PathKeyBefore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Key komori::PathKeyBefore </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>path_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Depth&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1手後の <code>path_key</code> と手 <code>move</code> から現在の <code>path_key</code> を計算する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path_key</td><td><code>move</code> 後の経路ハッシュ値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">move</td><td>次の手 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>現在の探索深さ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>move</code> 前の経路ハッシュ値</dd></dl>
<p><code>depth</code> は <code>move</code> する直前の深さを渡す必要がある。すなわち、以下の2つの関数は互いに逆写像の関係になっている。</p>
<ul>
<li><code>PathKeyAfter(・, move, depth)</code></li>
<li><code>PathKeyBefore(・, move, depth)</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>PathKeyAfter</code> は XOR に基づく差分計算をしているため、逆写像も全く同じ関数で実現できる </dd></dl>

<p class="definition">Definition at line <a class="el" href="path__keys_8hpp_source.html#l00097">97</a> of file <a class="el" href="path__keys_8hpp_source.html">path_keys.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_af65c288516ec71f448f2947aac9e755b_cgraph.png" border="0" usemap="#anamespacekomori_af65c288516ec71f448f2947aac9e755b_cgraph" alt=""/></div>
<map name="anamespacekomori_af65c288516ec71f448f2947aac9e755b_cgraph" id="anamespacekomori_af65c288516ec71f448f2947aac9e755b_cgraph">
<area shape="rect" title="1手後の path_key と手 move から現在の path_key を計算する。" alt="" coords="5,5,176,32"/>
<area shape="rect" href="namespacekomori.html#ae0ab7ef1101897b620e05208fc8975ee" title="現在の path_key と手 move から1手後の path_key を計算する。" alt="" coords="224,5,383,32"/>
</map>
</div>

</div>
</div>
<a id="a3758efae8cd7b2132e88bdb7a145e072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3758efae8cd7b2132e88bdb7a145e072">&#9670;&nbsp;</a></span>PathKeyInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void komori::PathKeyInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>経路ハッシュのテーブルを初期化する。 </p>
<p>探索開始前に1回だけ呼び出す必要がある。 </p>

<p class="definition">Definition at line <a class="el" href="path__keys_8hpp_source.html#l00028">28</a> of file <a class="el" href="path__keys_8hpp_source.html">path_keys.hpp</a>.</p>

</div>
</div>
<a id="a44b8d6f27caaa6caaa22610dcc422328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b8d6f27caaa6caaa22610dcc422328">&#9670;&nbsp;</a></span>Phi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> komori::Phi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>dn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>or_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>φ値を計算する。現局面が <code>or_node</code> なら <code>pn</code>, そうでないなら <code>dn</code> を返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pn</td><td>pn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dn</td><td>dn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">or_node</td><td>現局面が OR <a class="el" href="classkomori_1_1_node.html" title="Position をラップして詰将棋特有の判定を追加するクラス。">Node</a> なら <code>true</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PnDn φ値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00217">217</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="a2bf7170c2ef58b6054c0ac2c51dab4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf7170c2ef58b6054c0ac2c51dab4ba">&#9670;&nbsp;</a></span>RemoveIfHandGivesOtherChecks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Hand komori::RemoveIfHandGivesOtherChecks </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hand&#160;</td>
          <td class="paramname"><em>disproof_hand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>局面 n の子局面がすべて 反証駒 disproof_hand で不詰であることが既知の場合、もとの局面 n の反証駒を計算する。 </p>
<p>OrNode の時に限り呼び出せる。 disproof_hand をそのまま返すのが基本だが、もし disproof_hand の中に局面 n では持っていない駒が含まれていた場合、 その駒を打つ手を初手とした詰みがあるかもしれない。（局面 n に含まれないので、前提となる子局面の探索には含まれない） そのため、現局面で持っていない種別の持ち駒がある場合は、反証駒から消す必要がある。</p>
<h3><a class="anchor" id="autotoc_md0"></a>
例</h3>
<div class="fragment"><div class="line">後手の持駒：飛二 角二 金四 銀四 桂三 香三 歩十六</div>
<div class="line">  ９ ８ ７ ６ ５ ４ ３ ２ １</div>
<div class="line">+---------------------------+</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・v玉|一</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|二</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ 歩|三</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|四</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|五</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|六</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|七</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|八</div>
<div class="line">| ・ ・ ・ ・ ・ ・ ・ ・ ・|九</div>
<div class="line">+---------------------------+</div>
<div class="line">先手の持駒：桂 香 歩</div>
</div><!-- fragment --><p>↑子局面はすべて金を持っていても詰まないが、現局面で金を持っているなら詰む</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>現在の局面 </td></tr>
    <tr><td class="paramname">disproof_hand</td><td>n に対する子局面の探索で得られた反証駒の極大集合 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hand disproof_hand から n で持っていない　かつ　王手になる持ち駒を除いた持ち駒 </dd></dl>

<p class="definition">Definition at line <a class="el" href="hands_8hpp_source.html#l00137">137</a> of file <a class="el" href="hands_8hpp_source.html">hands.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacekomori_a2bf7170c2ef58b6054c0ac2c51dab4ba_cgraph.png" border="0" usemap="#anamespacekomori_a2bf7170c2ef58b6054c0ac2c51dab4ba_cgraph" alt=""/></div>
<map name="anamespacekomori_a2bf7170c2ef58b6054c0ac2c51dab4ba_cgraph" id="anamespacekomori_a2bf7170c2ef58b6054c0ac2c51dab4ba_cgraph">
<area shape="rect" title="局面 n の子局面がすべて 反証駒 disproof_hand で不詰であることが既知の場合、もとの局面 n の反証駒を計算する。" alt="" coords="5,5,215,47"/>
<area shape="rect" href="namespacekomori.html#a48f3fa8cf78887150c3558bf0ebbf47c" title="hand から pr を消す" alt="" coords="263,13,425,39"/>
</map>
</div>

</div>
</div>
<a id="a7311d41d5455115265700ac2518036a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7311d41d5455115265700ac2518036a7">&#9670;&nbsp;</a></span>SaturatedAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Constraints&lt; std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T komori::SaturatedAdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>T</code> 型の値を足し合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値で丸める（符号なし型） </p>
<p><code>T</code> 型の値を足し合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値 or 下限値で丸める（符号つき型）</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>足し合わせる型（符号なし型） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><code>T</code> 型の値 </td></tr>
    <tr><td class="paramname">rhs</td><td><code>T</code> 型の値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> と <code>rhs</code> を足し合わせた値</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>足し合わせる型（符号つき型） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><code>T</code> 型の値 </td></tr>
    <tr><td class="paramname">rhs</td><td><code>T</code> 型の値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> と <code>rhs</code> を足し合わせた値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00080">80</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="aa65253422e6bdf5544f59a4937671cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65253422e6bdf5544f59a4937671cf1">&#9670;&nbsp;</a></span>SaturatedMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Constraints&lt; std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T komori::SaturatedMultiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>T</code> 型の値を掛け合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値で丸める（符号なし型） </p>
<p><code>T</code> 型の値を掛け合わせる。ただし、計算結果が <code>T</code> 型で表現できない場合は上限値 or 下限値で丸める（符号つき型）</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>掛け合わせる型（符号なし型） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><code>T</code> 型の値 </td></tr>
    <tr><td class="paramname">rhs</td><td><code>T</code> 型の値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> と <code>rhs</code> を掛け合わせた値</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>掛け合わせる型（符号つき型） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><code>T</code> 型の値 </td></tr>
    <tr><td class="paramname">rhs</td><td><code>T</code> 型の値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> と <code>rhs</code> を掛け合わせた値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00120">120</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="ae2a1de257f1363b6f913c501fa5c43c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a1de257f1363b6f913c501fa5c43c1">&#9670;&nbsp;</a></span>Skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::Skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterable の先頭 <code>kSkip</code> 要素をスキップする </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a></td><td>iterableの型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>iterable </td></tr>
    <tr><td class="paramname">skip</td><td>スキップする要素数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range-based for で先頭 <code>kSize</code> 要素を飛ばした要素が取れるような iterable </dd></dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00292">292</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="acd8be37a9f85d1912131fe1379f30e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8be37a9f85d1912131fe1379f30e70">&#9670;&nbsp;</a></span>Take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>take</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterable の先頭 <code>kTake</code> 要素だけを取ってくる </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a></td><td>iterableの型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>iterable </td></tr>
    <tr><td class="paramname">take</td><td>取ってくる要素数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range-based for で先頭 <code>kTake</code> 要素を飛ばした要素が取れるような iterable </dd></dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00338">338</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="ac8e4cfe49668438b31f8af11d1043bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e4cfe49668438b31f8af11d1043bbe">&#9670;&nbsp;</a></span>ToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string komori::ToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pn/dn 値を文字列に変換する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>pn/dn 値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>val</code> の文字列表現 </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00240">240</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="a3701bb050d01264c34af417070ac05b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3701bb050d01264c34af417070ac05b7">&#9670;&nbsp;</a></span>ToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , Constraints&lt; decltype(std::declval&lt; Range &gt;().begin()), decltype(std::declval&lt; Range &gt;().end())&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string komori::ToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>Move</code> の <a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a> オブジェクトをスペース区切りの <code>std::string</code> へ変換する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td><code>Move</code> のリスト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>range</code> をスペース区切りで文字列化したもの </dd></dl>

<p class="definition">Definition at line <a class="el" href="typedefs_8hpp_source.html#l00258">258</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a id="a592455f5972570f64271d49fa7ffe9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592455f5972570f64271d49fa7ffe9ff">&#9670;&nbsp;</a></span>WithIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = std::size_t, typename Range  = std::nullptr_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classkomori_1_1detail_1_1_with_index_impl.html">detail::WithIndexImpl</a>&lt;IndexType, <a class="el" href="classkomori_1_1_range.html">Range</a>&gt; komori::WithIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkomori_1_1_range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添字つきのrange-based for 文用オブジェクトを生成する。 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>添字の型。デフォルトは <code>std::size_t</code>。 </td></tr>
    <tr><td class="paramname"><a class="el" href="classkomori_1_1_range.html" title="イテレータの範囲を表す型。">Range</a></td><td>lvalue reference OR nothrow move constructible </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range-based for でイテレートするオブジェクト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>添字つきのrange-based for 文用オブジェクト</dd></dl>
<p>Pythonにおける enumerate と同様の役割。iterable なオブジェクトを受け取り、添字と要素のペアを受け取るような オブジェクトを返す。テンプレート引数の順番が <code>IndexType</code> の方が手前なのは、インデックス型だけを手軽に 変更できるようにするため。</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{3, 3, 4};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [i, x] = WithIndex&lt;std::uint32_t&gt;(vec)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00201">201</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<a id="a3abf9ca26f7022f402cd774514ce16a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abf9ca26f7022f402cd774514ce16a5">&#9670;&nbsp;</a></span>Zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1 , typename Range2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto komori::Zip </td>
          <td>(</td>
          <td class="paramtype">Range1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2つのrangeをpairでまとめたようなrangeを返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range1</td><td>range1 </td></tr>
    <tr><td class="paramname">range2</td><td>range2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2つのrangeをpairでまとめたようにiterateできるrangeを返す。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ranges_8hpp_source.html#l00424">424</a> of file <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac300cf6ad5859846af0891d87ef8ec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac300cf6ad5859846af0891d87ef8ec8f">&#9670;&nbsp;</a></span>kAncestorSearchThreshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#ae2b179f7c8adb463807f13c9d73ec34a">PnDn</a> komori::kAncestorSearchThreshold = 3 * <a class="el" href="namespacekomori.html#ae827eafdb768dc1d7ee921cf9a345694">kPnDnUnit</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>二重カウント回避のために局面を過去方向へ遡るとき、目をつぶる pn/dn の差 </p>
<p>例えば、以下のような探索経路を考える。最初の OR node で dn 値の二重カウントが疑われている。 現局面 current から探索路を逆順にたどり、本当に二重カウントが発生しているかどうかを判定したい。</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> count?                                  current(左へさかのぼりたい)</div>
<div class="line">     |                                            |</div>
<div class="line">     v                                            v</div>
<div class="line">  OR node --&gt; AND node --&gt; OR node --&gt; ... --&gt; AND node --&gt; ... --&gt; AND node</div>
<div class="line">          \                                                      /</div>
<div class="line">           -&gt; AND node --&gt; ...                                  -</div>
</div><!-- fragment --><p>例えば、経路中（分岐元除く）に以下のような OR node が 1 つでも含まれていれば、dn の二重カウントによる影響は小さい。 なぜなら、この OR node の dn 値は注目している（二重カウントが疑われる）パスではなく、別の局面の影響を強く 受けているためである。</p>
<div class="fragment"><div class="line">        path</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">OR node --&gt; AND node</div>
<div class="line">        \</div>
<div class="line">         -&gt; AND node (dn is very big)</div>
</div><!-- fragment --><p>上記は OR node における dn 値二重化カウント問題を考えたが、AND node における pn 値二重カウントに関しても同様である。</p>
<p><code>kAncestorSearchThreshold</code> は、このような「支流」の存在をどれだけ許容するかを制御する値である。すなわち、親子間の pn/dn 値の差が <code>kAncestorSearchThreshold</code> より大きいときは二重カウントではないとみなす。</p>
<p><code>kAncestorSearchThreshold</code> の値が小さいほど二重カウント判定が厳しくなる。そのため、二重カウントの検出漏れが 発生しやすくなる。一方、<code>kAncestorSearchThreshold</code> の値が大きいほど二重カウント判定が緩くなるため、二重カウントでない パスを二重カウントと誤判定して探索性能の劣化に繋がる。 </p>

<p class="definition">Definition at line <a class="el" href="double__count__elimination_8hpp_source.html#l00053">53</a> of file <a class="el" href="double__count__elimination_8hpp_source.html">double_count_elimination.hpp</a>.</p>

</div>
</div>
<a id="aae8622a1e13915d6e31f36e1541066ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8622a1e13915d6e31f36e1541066ce">&#9670;&nbsp;</a></span>kDepthMaxPlus1MateLen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a> komori::kDepthMaxPlus1MateLen = <a class="el" href="namespacekomori.html#a77f2c8a8bb15674cec7f462c2a5796b0">kDepthMaxMateLen</a> + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>詰み／不詰手数の最大値 + 1（範囲外値） </p>
<p><code>kDepthMaxMateLen</code> よりも大きな値を表す特別な定数。探索中に用いてはならず、変数の初期値としてのみ用いる。 詳しくは <code>kMinus1MateLen</code> も参照。 </p>

<p class="definition">Definition at line <a class="el" href="mate__len_8hpp_source.html#l00162">162</a> of file <a class="el" href="mate__len_8hpp_source.html">mate_len.hpp</a>.</p>

</div>
</div>
<a id="a197ec11c83aea5b797450b5c08e31279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197ec11c83aea5b797450b5c08e31279">&#9670;&nbsp;</a></span>kMinus1MateLen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a> komori::kMinus1MateLen = <a class="el" href="namespacekomori.html#a6277ec63507731b721341c17c86699ea">kZeroMateLen</a> - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>-1手詰め／-1手不詰（範囲外値） </p>
<p><code>kZeroMateLen</code> よりも小さな値を表す特別な定数。探索中に用いてはならず、変数の初期値としてのみ用いる。配列の中から 最も大きな詰み手数を調べたい場合に用いる。</p>
<div class="fragment"><div class="line"><a class="code" href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">MateLen</a> max_len = <a class="code" href="namespacekomori.html#a197ec11c83aea5b797450b5c08e31279">kMinus1MateLen</a>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; len : len_list) {  <span class="comment">// len_list 内の値は [kZeroMateLen, kDepthMaxMateLen] の範囲</span></div>
<div class="line">  max_len = std::max(max_len, len);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacekomori_html_a197ec11c83aea5b797450b5c08e31279"><div class="ttname"><a href="namespacekomori.html#a197ec11c83aea5b797450b5c08e31279">komori::kMinus1MateLen</a></div><div class="ttdeci">constexpr MateLen kMinus1MateLen</div><div class="ttdoc">-1手詰め／-1手不詰（範囲外値）</div><div class="ttdef"><b>Definition:</b> <a href="mate__len_8hpp_source.html#l00155">mate_len.hpp:155</a></div></div>
<div class="ttc" id="anamespacekomori_html_af2c3856a7c53116227693f8dcca64199"><div class="ttname"><a href="namespacekomori.html#af2c3856a7c53116227693f8dcca64199">komori::MateLen</a></div><div class="ttdeci">detail::MateLenImpl&lt; std::uint32_t &gt; MateLen</div><div class="ttdoc">詰み／不詰手数</div><div class="ttdef"><b>Definition:</b> <a href="mate__len_8hpp_source.html#l00124">mate_len.hpp:124</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mate__len_8hpp_source.html#l00155">155</a> of file <a class="el" href="mate__len_8hpp_source.html">mate_len.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
